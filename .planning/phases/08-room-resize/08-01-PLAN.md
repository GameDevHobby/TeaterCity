---
phase: 08-room-resize
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/room_building/operations/ResizeOperation.gd
autonomous: true

must_haves:
  truths:
    - "Resize validation correctly identifies furniture that would be outside new bounds"
    - "Resize validation correctly identifies furniture whose access tiles would be blocked"
    - "Resize validation fails when new bounds overlap another room's bounding box"
    - "Resize validation fails when new size violates room type constraints"
  artifacts:
    - path: "scripts/room_building/operations/ResizeOperation.gd"
      provides: "Stateless resize validation operation"
      exports: ["ResizeOperation", "ResizeValidationResult"]
  key_links:
    - from: "scripts/room_building/operations/ResizeOperation.gd"
      to: "scripts/storage/RoomInstance.gd"
      via: "furniture iteration for bounds checking"
      pattern: "room\\.furniture"
    - from: "scripts/room_building/operations/ResizeOperation.gd"
      to: "scripts/RoomManager.gd"
      via: "room overlap detection"
      pattern: "room_manager\\.get_all_rooms\\(\\)"
---

<objective>
Create ResizeOperation class with validation logic for room resize operations.

Purpose: Before executing a resize, we must validate that (1) all existing furniture fits within new bounds, (2) furniture access tiles are not blocked by new walls, (3) new bounds don't overlap other rooms, and (4) new size meets room type constraints. This operation provides the validation foundation that RoomResizeController will use for preview feedback and commit gating.

Output: `scripts/room_building/operations/ResizeOperation.gd` with ResizeValidationResult inner class and validate_resize() method.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-room-resize/08-RESEARCH.md

Key existing files to reference:
- scripts/room_building/operations/CollisionOperation.gd - tile validation patterns
- scripts/room_building/operations/WallOperation.gd - wall generation for checking furniture vs wall positions
- scripts/room_building/operations/DeletionOperation.gd - stateless operation pattern to follow
- scripts/storage/RoomInstance.gd - furniture data model with get_occupied_tiles(), get_access_tiles()
- scripts/RoomManager.gd - get_all_rooms() for overlap detection
- scripts/data/RoomTypeRegistry.gd - room type min/max size constraints
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ResizeOperation class with validation</name>
  <files>scripts/room_building/operations/ResizeOperation.gd</files>
  <action>
Create a new stateless RefCounted operation class following the DeletionOperation pattern.

**Inner class ResizeValidationResult:**
```gdscript
class ResizeValidationResult:
    var is_valid: bool = true
    var error: String = ""
    var blocked_furniture: Array[RoomInstance.FurniturePlacement] = []
    var overlapped_room: RoomInstance = null  # Room that new bounds would overlap
```

**Method: validate_resize(room: RoomInstance, new_box: Rect2i, room_manager: Node) -> ResizeValidationResult**

Validation steps IN ORDER:

1. **Room type size constraints** (check first - fast fail)
   - Get room type from RoomTypeRegistry.get_instance().get_room_type(room.room_type_id)
   - Check new_box.size against room_type.min_size and max_size
   - Allow swapped width/height (same logic as RoomBuildUI line 201-206)
   - If invalid: set error = "Invalid size: %dx%d to %dx%d required" and return

2. **Room overlap detection** (check second - fast fail)
   - Iterate room_manager.get_all_rooms()
   - Skip if other_room == room (same room)
   - Check if new_box intersects other_room.bounding_box using Rect2i.intersects()
   - If overlap: set error = "Would overlap with another room", set overlapped_room, return

3. **Furniture bounds validation** (check last - detailed feedback)
   - Generate new walls array using WallOperation.new().generate_walls(new_box)
   - For each furniture in room.furniture:
     - For each tile in furniture.get_occupied_tiles():
       - Check tile is inside new_box using _is_tile_in_box() helper
       - Check tile is NOT in new_walls array
       - If either fails: add furniture to blocked_furniture (if not already)
     - For each tile in furniture.get_access_tiles():
       - Check tile is inside new_box
       - Check tile is NOT in new_walls array
       - If either fails: add furniture to blocked_furniture (if not already)
   - If blocked_furniture.size() > 0:
     - set error = "%d furniture item(s) would be outside new bounds or have blocked access"

**Private helper: _is_tile_in_box(tile: Vector2i, box: Rect2i) -> bool**
```gdscript
func _is_tile_in_box(tile: Vector2i, box: Rect2i) -> bool:
    return tile.x >= box.position.x and tile.x < box.position.x + box.size.x \
       and tile.y >= box.position.y and tile.y < box.position.y + box.size.y
```

**Method: execute_resize(room: RoomInstance, new_box: Rect2i, wall_tilemap: TileMapLayer, room_manager: Node, exterior_walls: Array[Vector2i]) -> void**

This method performs the actual resize (delete old walls, generate new):
1. Create DeletionOperation and WallOperation instances
2. Delete old door visuals: deletion_op.delete_door_visuals(room, wall_tilemap)
3. Delete old wall visuals: deletion_op.delete_wall_visuals(room, wall_tilemap, room_manager, exterior_walls)
4. Clear room.doors array (doors reset on resize per requirement EDIT-03)
5. Update room.bounding_box = new_box
6. Generate new walls: room.walls = wall_op.generate_walls(new_box)
7. Create new wall visuals: wall_op.create_wall_visuals(room, wall_tilemap)
8. Emit room.placement_changed for auto-save

NOTE: Furniture stays in place - validation already confirmed it fits. Navigation update happens after door placement.
  </action>
  <verify>
File exists at scripts/room_building/operations/ResizeOperation.gd and contains:
- class_name ResizeOperation
- class ResizeValidationResult with is_valid, error, blocked_furniture, overlapped_room
- validate_resize() method with all three validation stages
- execute_resize() method for delete+rebuild workflow
- _is_tile_in_box() private helper
  </verify>
  <done>
ResizeOperation.gd created with complete validation logic that:
- Validates room type size constraints (both orientations)
- Detects overlapping rooms
- Identifies blocked furniture (footprint and access tiles)
- Provides detailed error messages
- Executes resize via delete+rebuild pattern
  </done>
</task>

</tasks>

<verification>
1. Read ResizeOperation.gd and verify all validation steps are implemented
2. Verify it follows stateless RefCounted pattern like DeletionOperation
3. Verify ResizeValidationResult inner class has all required fields
4. Verify execute_resize reuses existing DeletionOperation and WallOperation
</verification>

<success_criteria>
- ResizeOperation.gd exists with validate_resize() and execute_resize() methods
- Validation handles all three checks: size constraints, room overlap, furniture bounds
- Error messages are user-friendly
- Code follows existing operations pattern (RefCounted, stateless)
</success_criteria>

<output>
After completion, create `.planning/phases/08-room-resize/08-01-SUMMARY.md`
</output>
