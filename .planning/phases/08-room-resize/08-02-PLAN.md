---
phase: 08-room-resize
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - scripts/room_editing/RoomResizeController.gd
autonomous: true

must_haves:
  truths:
    - "Controller enters resize mode when enter_resize_mode() called with room"
    - "Controller tracks drag start/current position for box drawing input"
    - "Controller validates preview box via ResizeOperation during drag"
    - "Controller emits signals for preview updates and resize completion"
    - "Controller exits resize mode cleanly, emitting mode_exited signal"
  artifacts:
    - path: "scripts/room_editing/RoomResizeController.gd"
      provides: "Resize workflow state machine and input handling"
      exports: ["RoomResizeController"]
  key_links:
    - from: "scripts/room_editing/RoomResizeController.gd"
      to: "scripts/room_building/operations/ResizeOperation.gd"
      via: "validation and execution"
      pattern: "_resize_op\\.validate_resize"
    - from: "scripts/room_editing/RoomResizeController.gd"
      to: "scripts/utils/IsometricMath.gd"
      via: "screen to tile conversion"
      pattern: "IsometricMath\\.screen_to_tile"
---

<objective>
Create RoomResizeController class to manage the resize workflow state machine and input handling.

Purpose: This controller orchestrates the resize UX - user drags to define new bounding box (reusing the proven box-drawing input pattern from RoomBuildUI), controller validates via ResizeOperation during drag, shows preview feedback via signals, and commits resize when user releases with valid bounds.

Output: `scripts/room_editing/RoomResizeController.gd` with state machine, drag handling, and validation integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-room-resize/08-RESEARCH.md

Key existing files to reference:
- scripts/room_building/RoomBuildUI.gd lines 122-140 - box drawing input pattern to follow
- scripts/room_editing/DoorEditController.gd - edit mode state machine pattern
- scripts/room_editing/FurnitureEditController.gd - controller signal patterns
- scripts/room_building/operations/ResizeOperation.gd (from 08-01) - validation
- scripts/utils/IsometricMath.gd - screen_to_tile conversion
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RoomResizeController with state machine and input handling</name>
  <files>scripts/room_editing/RoomResizeController.gd</files>
  <action>
Create a new Control class following the DoorEditController pattern.

**Class structure:**

```gdscript
class_name RoomResizeController
extends Control

## Controller for room resize mode.
## Manages box drawing input to define new room bounds.
## Follows DoorEditController pattern for edit mode management.

# Signals
signal resize_started(room: RoomInstance)
signal preview_updated(new_box: Rect2i, validation: RefCounted)  # validation is ResizeValidationResult
signal resize_completed(room: RoomInstance)
signal resize_cancelled
signal mode_exited
signal door_placement_needed(room: RoomInstance)  # After resize, doors must be re-placed

# State machine
enum State { IDLE, DRAWING }
var _state: State = State.IDLE
var _current_room: RoomInstance = null
var _original_box: Rect2i  # Store original in case of cancel

# Drag state (same pattern as RoomBuildUI)
var _draw_start: Vector2i = Vector2i.ZERO
var _current_mouse_pos: Vector2i = Vector2i.ZERO
var _is_dragging: bool = false

# Validation state
var _resize_op: ResizeOperation = ResizeOperation.new()
var _last_validation: ResizeOperation.ResizeValidationResult = null
var _room_manager: Node = null
var _exterior_walls: Array[Vector2i] = []
var _wall_tilemap: TileMapLayer = null
```

**Lifecycle methods:**

```gdscript
func _ready() -> void:
    mouse_filter = MOUSE_FILTER_IGNORE  # Don't block input
    _room_manager = get_node("/root/RoomManager")
```

**Input handling (follow RoomBuildUI lines 122-140):**

```gdscript
func _input(event: InputEvent) -> void:
    if _state != State.DRAWING:
        return

    if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
        if event.pressed:
            _draw_start = _screen_to_tile(event.global_position)
            _current_mouse_pos = _draw_start
            _is_dragging = true
            _update_preview()
            queue_redraw()
        elif _is_dragging:
            _is_dragging = false
            _try_commit_resize()
    elif event is InputEventMouseMotion and _is_dragging:
        _current_mouse_pos = _screen_to_tile(event.global_position)
        _update_preview()
        queue_redraw()

func _unhandled_input(event: InputEvent) -> void:
    if _state != State.IDLE and event.is_action_pressed("ui_cancel"):
        exit_resize_mode()
        get_viewport().set_input_as_handled()
```

**Coordinate conversion:**

```gdscript
func _screen_to_tile(screen_pos: Vector2) -> Vector2i:
    return IsometricMath.screen_to_tile(screen_pos, get_viewport())
```

**Preview update (validate during drag):**

```gdscript
func _update_preview() -> void:
    var preview_box = _get_preview_box()
    _last_validation = _resize_op.validate_resize(_current_room, preview_box, _room_manager)
    preview_updated.emit(preview_box, _last_validation)

func _get_preview_box() -> Rect2i:
    var min_tile = Vector2i(
        mini(_draw_start.x, _current_mouse_pos.x),
        mini(_draw_start.y, _current_mouse_pos.y)
    )
    var max_tile = Vector2i(
        maxi(_draw_start.x, _current_mouse_pos.x),
        maxi(_draw_start.y, _current_mouse_pos.y)
    )
    # Create Rect2i from min to max (size is max - min + 1)
    return Rect2i(min_tile, max_tile - min_tile + Vector2i.ONE)
```

**Commit resize (on mouse release):**

```gdscript
func _try_commit_resize() -> void:
    if _last_validation == null or not _last_validation.is_valid:
        # Invalid - don't commit, show error feedback
        # User can try again or cancel
        queue_redraw()
        return

    var new_box = _get_preview_box()

    # Execute the resize
    _resize_op.execute_resize(_current_room, new_box, _wall_tilemap, _room_manager, _exterior_walls)

    # Emit completion
    resize_completed.emit(_current_room)

    # Doors need to be re-placed (requirement EDIT-03)
    door_placement_needed.emit(_current_room)

    # Exit drawing state but DON'T emit mode_exited - door placement will handle that
    _state = State.IDLE
    _is_dragging = false
    queue_redraw()
```

**Public API:**

```gdscript
func enter_resize_mode(room: RoomInstance) -> void:
    if room == null:
        return

    _current_room = room
    _original_box = room.bounding_box
    _state = State.DRAWING
    _is_dragging = false
    _last_validation = null
    resize_started.emit(room)
    queue_redraw()

func exit_resize_mode() -> void:
    _state = State.IDLE
    _current_room = null
    _is_dragging = false
    _last_validation = null
    resize_cancelled.emit()
    mode_exited.emit()
    queue_redraw()

func is_active() -> bool:
    return _state != State.IDLE

func get_current_room() -> RoomInstance:
    return _current_room

func get_preview_box() -> Rect2i:
    if not _is_dragging:
        return Rect2i()
    return _get_preview_box()

func get_last_validation() -> ResizeOperation.ResizeValidationResult:
    return _last_validation

func set_exterior_walls(walls: Array[Vector2i]) -> void:
    _exterior_walls = walls

func set_wall_tilemap(tilemap: TileMapLayer) -> void:
    _wall_tilemap = tilemap
```

**IMPORTANT:** This controller does NOT handle visual drawing. The RoomResizeHighlight (plan 03) subscribes to preview_updated signal and handles all rendering. This matches the established pattern where controllers emit signals and highlights render visuals.
  </action>
  <verify>
File exists at scripts/room_editing/RoomResizeController.gd and contains:
- class_name RoomResizeController
- State enum with IDLE, DRAWING
- All signals: resize_started, preview_updated, resize_completed, resize_cancelled, mode_exited, door_placement_needed
- Drag handling following RoomBuildUI input pattern
- Integration with ResizeOperation for validation
- Public methods: enter_resize_mode, exit_resize_mode, is_active, get_current_room, get_preview_box, get_last_validation
  </verify>
  <done>
RoomResizeController.gd created with:
- State machine (IDLE, DRAWING)
- Box drawing input handling (drag to define new bounds)
- Live validation during drag via ResizeOperation
- Signals for preview updates and completion
- door_placement_needed signal for post-resize door re-placement
  </done>
</task>

</tasks>

<verification>
1. Read RoomResizeController.gd and verify state machine states
2. Verify input handling matches RoomBuildUI pattern
3. Verify validation is called during drag (_update_preview)
4. Verify commit logic checks validation before executing
5. Verify door_placement_needed signal is emitted after successful resize
</verification>

<success_criteria>
- RoomResizeController.gd exists with complete state machine
- Input handling uses same pattern as RoomBuildUI box drawing
- Validation runs live during drag
- Successful resize triggers door_placement_needed signal
- Controller can be cancelled via ui_cancel action
</success_criteria>

<output>
After completion, create `.planning/phases/08-room-resize/08-02-SUMMARY.md`
</output>
