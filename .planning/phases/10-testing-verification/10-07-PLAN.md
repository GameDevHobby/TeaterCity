---
phase: 10-testing-verification
plan: 07
type: execute
wave: 2
depends_on:
  - "10-04"
files_modified:
  - test/integration/test_furniture_edit_flow.gd
autonomous: true

must_haves:
  truths:
    - "Furniture can be selected via FurnitureEditController"
    - "Selected furniture can be moved to new position"
    - "Furniture move emits correct signal"
    - "Furniture delete removes from room data"
  artifacts:
    - path: "test/integration/test_furniture_edit_flow.gd"
      provides: "Integration tests for furniture editing workflow"
      min_lines: 80
  key_links:
    - from: "test/integration/test_furniture_edit_flow.gd"
      to: "scripts/room_building/controllers/FurnitureEditController.gd"
      via: "controller instantiation and signal watching"
      pattern: "FurnitureEditController\\.new\\(\\)|furniture_(selected|moved|deleted)"
---

<objective>
Create integration tests for furniture editing workflows.

Purpose: TEST-04 requires integration tests for edit workflows. Tests verify the full furniture edit flow: select -> edit -> signal emission, simulating controller interactions without visual components.

Output: `test/integration/test_furniture_edit_flow.gd` with workflow tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-testing-verification/10-RESEARCH.md

# Reference implementation
@scripts/room_building/controllers/FurnitureEditController.gd

# Test patterns to follow
@test/integration/test_room_build_flow.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_furniture_edit_flow.gd with workflow tests</name>
  <files>test/integration/test_furniture_edit_flow.gd</files>
  <action>
Create integration test file following test_room_build_flow.gd patterns.

First, examine FurnitureEditController.gd to understand:
- How to instantiate and initialize the controller
- What signals it emits (furniture_selected, furniture_moved, furniture_deleted, etc.)
- What methods trigger state changes

Test structure:
```gdscript
extends GutTest

## Integration tests for furniture editing workflow
## Tests controller state transitions and signal flow

var _controller: FurnitureEditController
var _wall_op: WallOperation
var _test_room: RoomInstance

func before_each() -> void:
    _wall_op = WallOperation.new()

    # Create test room with furniture
    _test_room = _create_room_with_furniture()

    # Create controller - check what constructor parameters it needs
    _controller = FurnitureEditController.new()
    _controller.name = "TestFurnitureEditController"
    add_child_autofree(_controller)

func after_each() -> void:
    _controller = null
    _test_room = null
    _wall_op = null

func _create_test_furniture() -> FurnitureResource:
    var furn = FurnitureResource.new()
    furn.id = "test_chair"
    furn.size = Vector2i(1, 1)
    return furn

func _create_room_with_furniture() -> RoomInstance:
    var room = RoomInstance.new("test_room", "lobby")
    room.bounding_box = Rect2i(0, 0, 6, 6)
    room.walls = _wall_op.generate_walls(room.bounding_box)
    room.add_door(Vector2i(2, 0), 0)

    var furn = _create_test_furniture()
    room.add_furniture(furn, Vector2i(2, 2), 0)
    room.add_furniture(furn, Vector2i(3, 3), 0)
    return room
```

Tests (adjust based on actual FurnitureEditController API):

Selection tests:
- `test_initial_state_no_selection()` - no furniture selected initially
- `test_select_furniture_emits_signal()` - selecting furniture emits furniture_selected signal
- `test_select_furniture_updates_state()` - selected_furniture property updated
- `test_deselect_furniture()` - can deselect and selected_furniture becomes null

Move tests:
- `test_move_furniture_to_valid_position()` - moving furniture to empty tile succeeds
- `test_move_furniture_emits_signal()` - move emits furniture_moved signal
- `test_move_updates_placement_position()` - FurniturePlacement.position updated
- `test_move_blocked_by_wall()` - moving to wall position fails

Delete tests:
- `test_delete_furniture_removes_from_room()` - delete removes furniture from room.furniture array
- `test_delete_emits_signal()` - delete emits furniture_deleted signal
- `test_delete_clears_selection()` - selected_furniture null after delete

Edit mode lifecycle:
- `test_enter_edit_mode()` - can enter edit mode for a room
- `test_exit_edit_mode()` - can exit edit mode, clears state
- `test_signal_sequence()` - verify correct signal order during operations

Note: If FurnitureEditController requires visual components or RoomManager, create mock objects or skip tests that can't be isolated.
  </action>
  <verify>
Run: `godot --headless --script addons/gut/gut_cmdln.gd -gtest=res://test/integration/test_furniture_edit_flow.gd`

All tests should pass.
  </verify>
  <done>
- FurnitureEditController can be instantiated and added to scene tree
- Selection workflow tested (select, deselect, state changes)
- Move workflow tested (valid move, blocked move, signal emission)
- Delete workflow tested (remove from room, signal emission)
- Edit mode lifecycle tested
- All tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# Run furniture edit flow tests
godot --headless --script addons/gut/gut_cmdln.gd -gtest=res://test/integration/test_furniture_edit_flow.gd

# Verify test file exists
grep -c "func test_" test/integration/test_furniture_edit_flow.gd
# Should return 10+
```
</verification>

<success_criteria>
1. test_furniture_edit_flow.gd exists with 10+ test methods
2. All tests pass when run with GUT
3. Selection workflow verified with signals
4. Move workflow verified with position updates
5. Delete workflow verified with array removal
6. Uses add_child_autofree for proper cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/10-testing-verification/10-07-SUMMARY.md`
</output>
