---
phase: 10-testing-verification
plan: 06
type: execute
wave: 2
depends_on:
  - "10-05"
files_modified:
  - test/unit/test_room_serializer_edge_cases.gd
autonomous: true

must_haves:
  truths:
    - "Corrupted JSON file returns empty array gracefully"
    - "Invalid JSON structure returns empty array gracefully"
    - "Large room sets can be saved and loaded"
    - "Special characters in room IDs preserved"
  artifacts:
    - path: "test/unit/test_room_serializer_edge_cases.gd"
      provides: "Unit tests for RoomSerializer edge cases and error handling"
      min_lines: 60
  key_links:
    - from: "test/unit/test_room_serializer_edge_cases.gd"
      to: "scripts/storage/RoomSerializer.gd"
      via: "static method calls with malformed input"
      pattern: "RoomSerializer\\.load_rooms"
---

<objective>
Create unit tests for RoomSerializer edge cases and error handling.

Purpose: TEST-03 requires comprehensive persistence layer tests including edge cases. This plan covers corrupted files, invalid structures, large datasets, and boundary conditions that the happy path tests don't cover.

Output: `test/unit/test_room_serializer_edge_cases.gd` with edge case and error handling tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-testing-verification/10-RESEARCH.md
@.planning/phases/10-testing-verification/10-05-SUMMARY.md

# Reference implementation
@scripts/storage/RoomSerializer.gd

# Test patterns to follow
@test/unit/test_room_serializer.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_room_serializer_edge_cases.gd</name>
  <files>test/unit/test_room_serializer_edge_cases.gd</files>
  <action>
Create unit test file for edge cases. These tests need to write malformed files directly to test error handling.

Test structure:
```gdscript
extends GutTest

## Unit tests for RoomSerializer edge cases
## Tests error handling, corrupted files, and boundary conditions

const SAVE_PATH := "user://saves/rooms.json"
const SAVE_DIR := "user://saves"

var _wall_op: WallOperation

func before_each() -> void:
    _wall_op = WallOperation.new()
    RoomSerializer.delete_save_file()
    # Ensure clean directory
    if not DirAccess.dir_exists_absolute(SAVE_DIR):
        DirAccess.make_dir_recursive_absolute(SAVE_DIR)

func after_each() -> void:
    RoomSerializer.delete_save_file()
    _wall_op = null

func _write_raw_file(content: String) -> void:
    var file = FileAccess.open(SAVE_PATH, FileAccess.WRITE)
    file.store_string(content)
    file.close()
```

Tests for corrupted JSON:
- `test_load_invalid_json_syntax()` - file with `{invalid json` returns empty array
- `test_load_truncated_json()` - file cut off mid-content returns empty array
- `test_load_empty_file()` - completely empty file returns empty array
- `test_load_null_json()` - file containing just `null` returns empty array
- `test_load_array_root()` - file with array (not dict) root returns empty array

Tests for invalid structure:
- `test_load_missing_rooms_key()` - dict without "rooms" key returns empty array
- `test_load_rooms_not_array()` - "rooms" is a string instead of array returns empty array
- `test_load_room_not_dict()` - room entry is string instead of dict skips it
- `test_load_partial_valid_rooms()` - mix of valid and invalid rooms loads only valid ones

Tests for boundary conditions:
- `test_save_load_large_room_set()` - save/load 50+ rooms works correctly
- `test_special_characters_in_id()` - room id with "test-room_1" preserved
- `test_unicode_in_room_id()` - room id with unicode characters preserved (if supported)
- `test_negative_bounding_box()` - room at negative coordinates preserved
- `test_zero_size_bounding_box()` - degenerate room handled gracefully

Tests for graceful degradation:
- `test_corrupted_does_not_crash()` - any corrupt file returns empty, never crashes
- `test_error_does_not_delete_file()` - corrupt file still exists after failed load

Large room set test detail:
```gdscript
func test_save_load_large_room_set() -> void:
    var rooms: Array[RoomInstance] = []
    for i in range(50):
        var room = RoomInstance.new("room_%d" % i, "lobby")
        room.bounding_box = Rect2i(i * 10, 0, 5, 5)
        room.walls = _wall_op.generate_walls(room.bounding_box)
        rooms.append(room)

    var save_result = RoomSerializer.save_rooms(rooms)
    assert_true(save_result, "Should save large room set")

    var loaded = RoomSerializer.load_rooms()
    assert_eq(loaded.size(), 50, "Should load all 50 rooms")
```
  </action>
  <verify>
Run: `godot --headless --script addons/gut/gut_cmdln.gd -gtest=res://test/unit/test_room_serializer_edge_cases.gd`

All tests should pass. No crashes on corrupted files.
  </verify>
  <done>
- Corrupted JSON handled gracefully (returns empty array)
- Invalid structure handled gracefully
- Partial valid data loads only valid entries
- Large datasets (50+ rooms) work correctly
- Special characters and edge cases handled
- Tests clean up after themselves
- All tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# Run edge case tests
godot --headless --script addons/gut/gut_cmdln.gd -gtest=res://test/unit/test_room_serializer_edge_cases.gd

# Verify test file exists
grep -c "func test_" test/unit/test_room_serializer_edge_cases.gd
# Should return 12+
```
</verification>

<success_criteria>
1. test_room_serializer_edge_cases.gd exists with 12+ test methods
2. All tests pass when run with GUT
3. Corrupted JSON files return empty array (no crash)
4. Invalid structures return empty array
5. Large room sets work correctly
6. Special characters preserved
7. Tests clean up after themselves
</success_criteria>

<output>
After completion, create `.planning/phases/10-testing-verification/10-06-SUMMARY.md`
</output>
