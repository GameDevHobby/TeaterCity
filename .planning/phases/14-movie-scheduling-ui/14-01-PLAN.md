---
phase: 14-movie-scheduling-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/storage/RoomInstance.gd
  - scripts/Main.gd
autonomous: true

must_haves:
  truths:
    - "Scheduling a theater stores the selected movie on the room"
    - "Theater scheduling only triggers from idle state"
    - "Movie choices come from a runtime pool that exists on startup"
  artifacts:
    - path: "scripts/storage/RoomInstance.gd"
      provides: "Persistent theater schedule payload"
      contains: "scheduled movie fields in to_dict/from_dict"
    - path: "scripts/Main.gd"
      provides: "Movie pool bootstrap and schedule application logic"
      contains: "idle-only scheduling method"
  key_links:
    - from: "scripts/Main.gd"
      to: "scripts/storage/MoviePoolSerializer.gd"
      via: "startup load/generate/save bootstrap"
      pattern: "MoviePoolSerializer\\.(load_pool|save_pool)"
    - from: "scripts/Main.gd"
      to: "scripts/storage/RoomInstance.gd"
      via: "selected movie assignment before transition"
      pattern: "set_.*movie|scheduled_movie"
---

<objective>
Create scheduling data plumbing so theater scheduling can assign a real movie and persist it safely.

Purpose: Deliver the core non-UI behavior for THTR-06 so the UI can call a single reliable scheduling path.
Output: RoomInstance theater scheduling payload and Main.gd runtime movie-pool + scheduling methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-movie-scheduling-ui/14-CONTEXT.md
@.planning/phases/14-movie-scheduling-ui/14-RESEARCH.md
@.planning/phases/12-movie-data-system/12-02-SUMMARY.md
@.planning/phases/13-theater-state-machine/13-01-SUMMARY.md
@scripts/storage/RoomInstance.gd
@scripts/Main.gd
@scripts/storage/MoviePool.gd
@scripts/storage/MoviePoolSerializer.gd
@scripts/generation/MovieGenerator.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add persistent theater scheduled-movie payload on RoomInstance</name>
  <files>scripts/storage/RoomInstance.gd</files>
  <action>
Extend `RoomInstance` with theater scheduling data for the selected movie, including enough fields to satisfy UI and save/reload behavior (movie id, title, genre, rating, duration).

Add explicit helper methods (for example `set_scheduled_movie(movie: MovieResource)` and `clear_scheduled_movie()`) so callers do not mutate fields ad hoc. Ensure helper usage emits `placement_changed` for auto-save.

Update `to_dict()` and `from_dict()` to serialize/restore the schedule payload with safe defaults and backward compatibility for older room payloads that do not include movie scheduling keys.

If schema versioning is used for room payload fields, bump version and keep compatibility handling explicit in `from_dict()`.
  </action>
  <verify>
Inspect `scripts/storage/RoomInstance.gd` and confirm:
1. Scheduled movie data is represented as typed fields.
2. Serialization writes a dedicated schedule payload.
3. Deserialization restores payload when present and keeps defaults when absent.
4. Setting/clearing movie emits `placement_changed`.
  </verify>
  <done>
RoomInstance can store, clear, serialize, and deserialize selected theater movie data without breaking existing room saves.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire runtime movie pool bootstrap and idle-only scheduling API in Main</name>
  <files>scripts/Main.gd</files>
  <action>
Add runtime movie pool ownership to `Main.gd`:
- On startup, attempt `MoviePoolSerializer.load_pool()`.
- If missing/null/empty, generate default movies via `MovieGenerator`, fill a `MoviePool`, and persist with `MoviePoolSerializer.save_pool()`.

Add explicit methods to:
- Return available movies for scheduling (copy-safe list from pool).
- Apply scheduling for a target room and selected movie ID with strict guards:
  - room must be theater
  - room must have initialized state machine
  - room must be in `idle`
  - selected movie must exist in pool

On valid schedule, set room scheduled-movie payload first, then transition state machine to `scheduled`. Keep all direct `idle -> scheduled` transition logic centralized in this new method.
  </action>
  <verify>
Run:
`godot --headless --path . --quit`

Then code-check `scripts/Main.gd` for:
- movie pool load/generate/save bootstrap in startup path,
- one central scheduling method with idle-only guards,
- movie assignment happening before transition to `scheduled`.
  </verify>
  <done>
Main.gd owns a non-empty runtime movie pool and exposes a single guarded scheduling path that stores selected movie and transitions idle theaters to scheduled.
  </done>
</task>

</tasks>

<verification>
1. Startup path always yields usable movie pool data.
2. Theater schedule payload is persisted through RoomInstance serialization.
3. Scheduling from non-idle or non-theater rooms is rejected cleanly.
4. Valid scheduling sets movie payload then moves state to `scheduled`.
</verification>

<success_criteria>
- [ ] `RoomInstance` has explicit scheduled-movie storage helpers
- [ ] Scheduled movie data round-trips through room save/load
- [ ] `Main.gd` bootstraps movie pool from save or generation fallback
- [ ] `Main.gd` exposes idle-only scheduling API
- [ ] Headless parse check succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/14-movie-scheduling-ui/14-01-SUMMARY.md`
</output>
