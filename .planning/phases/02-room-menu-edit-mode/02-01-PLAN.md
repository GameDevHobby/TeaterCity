---
phase: 02-room-menu-edit-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/room_editing/RoomEditMenu.gd
  - scripts/Main.gd
autonomous: true

must_haves:
  truths:
    - "Selecting a room shows a menu near the room"
    - "Menu has three buttons: Edit Furniture, Edit Room, room-type-specific"
    - "Room-type button shows contextual label based on room type"
    - "Clicking outside menu clears selection and hides menu"
    - "Selecting another room moves menu to new room"
  artifacts:
    - path: "scripts/room_editing/RoomEditMenu.gd"
      provides: "Contextual menu Control with PanelContainer"
      exports: ["RoomEditMenu"]
      min_lines: 80
    - path: "scripts/Main.gd"
      provides: "CanvasLayer creation and signal wiring"
      contains: "EditMenuLayer"
  key_links:
    - from: "scripts/room_editing/RoomEditMenu.gd"
      to: "RoomManager"
      via: "signal connections in _ready()"
      pattern: "RoomManager\\.room_selected\\.connect"
    - from: "scripts/room_editing/RoomEditMenu.gd"
      to: "IsometricMath"
      via: "tile_to_screen for positioning"
      pattern: "IsometricMath\\.tile_to_screen"
    - from: "scripts/Main.gd"
      to: "scripts/room_editing/RoomEditMenu.gd"
      via: "CanvasLayer child creation"
      pattern: "RoomEditMenu\\.new\\(\\)"
---

<objective>
Create a contextual room edit menu that appears when a player selects a room.

Purpose: Enable players to access room editing options (Edit Furniture, Edit Room, room-type-specific actions) after selecting a completed room. This is the entry point for all room modification workflows in later phases.

Output: RoomEditMenu.gd Control that positions itself near the selected room and provides three styled buttons. Main.gd updated to create the menu in a CanvasLayer.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-room-menu-edit-mode/02-RESEARCH.md

# Key existing files
@scripts/RoomManager.gd
@scripts/Main.gd
@scripts/utils/UIStyleHelper.gd
@scripts/utils/IsometricMath.gd
@scripts/data/RoomTypeRegistry.gd
@scripts/storage/RoomInstance.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RoomEditMenu Control</name>
  <files>scripts/room_editing/RoomEditMenu.gd</files>
  <action>
Create RoomEditMenu.gd in scripts/room_editing/ directory (create directory if needed).

The Control should:
1. Extend Control with class_name RoomEditMenu
2. Emit signals: edit_furniture_pressed(room), edit_room_pressed(room), room_type_action_pressed(room)
3. Track _current_room: RoomInstance and UI elements (_panel, _edit_furniture_btn, _edit_room_btn, _room_type_btn)

In _ready():
- Set mouse_filter = MOUSE_FILTER_IGNORE (don't block clicks to rooms below)
- Set anchors to PRESET_FULL_RECT
- Call _create_panel() to build UI
- hide() initially
- Connect to RoomManager.room_selected and RoomManager.selection_cleared signals

In _create_panel():
- Create PanelContainer with mouse_filter = MOUSE_FILTER_STOP (capture button clicks)
- Apply UIStyleHelper.apply_panel_style(_panel)
- Add MarginContainer child with 12px margins all sides
- Add VBoxContainer child with 8px separation
- Create three buttons using UIStyleHelper.create_styled_button():
  - "Edit Furniture" (160x40)
  - "Edit Room" (160x40)
  - Room-type button with empty text initially (160x40)
- Connect each button's pressed signal to _on_edit_furniture/_on_edit_room/_on_room_type_action

In _unhandled_input(event):
- Return early if not visible or _current_room is null
- Handle both InputEventScreenTouch (mobile: not event.pressed) and InputEventMouseButton (desktop: event.pressed with MOUSE_BUTTON_LEFT)
- Check if click is outside panel_rect using Rect2(_panel.global_position, _panel.size).has_point(click_pos)
- If outside: call RoomManager.clear_selection() and get_viewport().set_input_as_handled()

In _on_room_selected(room):
- Store _current_room = room
- Call _update_room_type_button(room)
- Call _position_near_room(room)
- show()

In _on_selection_cleared():
- Set _current_room = null
- hide()

In _position_near_room(room):
- Calculate center tile from room.bounding_box (position + size/2)
- Convert to screen position using IsometricMath.tile_to_screen(center_tile, get_viewport())
- await get_tree().process_frame (wait for panel size calculation)
- Apply offset Vector2(30, -_panel.size.y / 2) to position right of room center
- Clamp to viewport bounds with 8px margin

In _update_room_type_button(room):
- Get room type from RoomTypeRegistry.get_instance().get_room_type(room.room_type_id)
- If found, set _room_type_btn.text = _get_room_type_feature(room_type.id)
- Otherwise set to "Room Options"

In _get_room_type_feature(room_type_id):
- Use match statement to map room types to feature names:
  - "theater_auditorium" -> "Theater Schedule"
  - "ticket_counter" -> "Ticket Prices"
  - "snack_bar" -> "Menu Items"
  - "bathroom" -> "Maintenance"
  - "lobby" -> "Decorations"
  - _ -> "Room Options"

Button handlers (_on_edit_furniture, _on_edit_room, _on_room_type_action):
- Check if _current_room is not null
- Emit corresponding signal with _current_room

IMPORTANT: The RoomTypeRegistry may not have room types configured yet. Handle null gracefully.
  </action>
  <verify>
- File exists at scripts/room_editing/RoomEditMenu.gd
- Run: godot --headless --path . --script res://scripts/room_editing/RoomEditMenu.gd (check for parse errors)
- Verify class_name RoomEditMenu is declared
- Verify signals are declared
- Verify RoomManager signal connections in _ready()
  </verify>
  <done>
RoomEditMenu.gd exists with:
- Three signals for button presses
- PanelContainer with three styled buttons
- Positioning logic using IsometricMath.tile_to_screen
- Outside-click dismiss handling for both touch and mouse
- Room-type-specific button label mapping
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate RoomEditMenu with Main.gd</name>
  <files>scripts/Main.gd</files>
  <action>
Modify Main.gd to create and wire up the RoomEditMenu.

In _ready(), after the existing SelectionHighlightLayer creation block, add:

1. Create edit menu CanvasLayer:
```gdscript
var edit_menu_layer = CanvasLayer.new()
edit_menu_layer.name = "EditMenuLayer"
edit_menu_layer.layer = 1  # Above selection highlight (layer 0)
add_child(edit_menu_layer)
```

2. Create RoomEditMenu instance:
```gdscript
var edit_menu = RoomEditMenu.new()
edit_menu.name = "RoomEditMenu"
edit_menu_layer.add_child(edit_menu)
```

3. Connect edit menu signals to stub handlers:
```gdscript
edit_menu.edit_furniture_pressed.connect(_on_edit_furniture_requested)
edit_menu.edit_room_pressed.connect(_on_edit_room_requested)
edit_menu.room_type_action_pressed.connect(_on_room_type_action_requested)
```

4. Add stub handler methods (placeholder for future phases):
```gdscript
func _on_edit_furniture_requested(room: RoomInstance) -> void:
    print("Edit furniture requested: ", room.id)

func _on_edit_room_requested(room: RoomInstance) -> void:
    print("Edit room requested: ", room.id)

func _on_room_type_action_requested(room: RoomInstance) -> void:
    print("Room type action requested: ", room.id, " type: ", room.room_type_id)
```

5. Remove or update the existing _on_room_selected stub that just prints - it's now handled by RoomEditMenu directly connecting to RoomManager.

NOTE: Keep the existing RoomManager.room_selected.connect(_on_room_selected) if you want Main.gd to also react to selection, or remove it since RoomEditMenu handles showing the menu.
  </action>
  <verify>
- Run: godot --headless --path . -s res://scripts/Main.gd (check for parse errors)
- Verify EditMenuLayer and RoomEditMenu creation code exists
- Verify three stub handler functions exist
  </verify>
  <done>
Main.gd updated with:
- EditMenuLayer CanvasLayer (layer=1) creation
- RoomEditMenu instance creation as child
- Signal connections to stub handlers
- Stub handlers that print for Phase 3+ implementation
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Parse check:** Run `godot --headless --path . --quit` to verify no script errors

2. **Manual test sequence:**
   - Run the game
   - Build a room (enter build mode, draw box, place door)
   - Exit build mode
   - Click/tap the completed room
   - Verify: Yellow selection highlight appears
   - Verify: Menu panel appears near the room with three buttons
   - Verify: Buttons are styled consistently with existing UI
   - Click/tap outside the menu
   - Verify: Menu disappears and selection clears
   - Click/tap the room again
   - Verify: Menu reappears

3. **Room type button:** Currently room_type_id may not be set (depends on RoomBuildController implementation). If "Room Options" appears, that's correct fallback behavior.
</verification>

<success_criteria>
1. Menu appears within 100px of selected room's visual center
2. Menu displays three buttons with consistent pixel-art styling
3. Third button shows "Room Options" (or room-type-specific label if type is set)
4. Clicking outside menu clears selection and hides menu
5. Selecting different room repositions menu correctly
6. Works on both desktop (mouse) and mobile (touch) input
</success_criteria>

<output>
After completion, create `.planning/phases/02-room-menu-edit-mode/02-01-SUMMARY.md`
</output>
