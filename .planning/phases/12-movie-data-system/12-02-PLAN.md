---
phase: 12-movie-data-system
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - Scripts/generation/MovieGenerator.gd
  - Scripts/storage/MoviePool.gd
  - Scripts/storage/MoviePoolSerializer.gd
autonomous: true

must_haves:
  truths:
    - "MovieGenerator produces varied movies with different titles, genres, ratings, durations"
    - "MoviePool stores a collection of available movies"
    - "MoviePool serializes and deserializes correctly"
    - "MoviePoolSerializer saves to file atomically"
  artifacts:
    - path: "Scripts/generation/MovieGenerator.gd"
      provides: "Procedural movie generation"
      exports: ["MovieGenerator"]
      min_lines: 40
    - path: "Scripts/storage/MoviePool.gd"
      provides: "Runtime movie pool storage"
      exports: ["MoviePool"]
      min_lines: 30
    - path: "Scripts/storage/MoviePoolSerializer.gd"
      provides: "JSON persistence for movie pool"
      exports: ["MoviePoolSerializer"]
      min_lines: 40
  key_links:
    - from: "MovieGenerator.generate_movie()"
      to: "MovieResource"
      via: "creates instances"
      pattern: "MovieResource\\.new\\(\\)"
    - from: "MoviePool.to_dict()"
      to: "MovieResource.to_dict()"
      via: "serializes contained movies"
      pattern: "movie\\.to_dict\\(\\)|to_dict\\(\\)"
    - from: "MoviePoolSerializer.save_pool()"
      to: "MoviePool.to_dict()"
      via: "serializes pool to JSON"
      pattern: "pool\\.to_dict\\(\\)"
---

<objective>
Create movie generation and pool management systems.

Purpose: Enable procedural movie generation (THTR-04) and runtime pool storage with persistence.
Output: MovieGenerator for creating varied movies, MoviePool for storing available movies, MoviePoolSerializer for persistence.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase research
@.planning/phases/12-movie-data-system/12-RESEARCH.md

# Prior plan output
@.planning/phases/12-movie-data-system/12-01-SUMMARY.md

# Pattern references
@Scripts/storage/RoomInstance.gd
@Scripts/storage/RoomSerializer.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MovieGenerator class</name>
  <files>Scripts/generation/MovieGenerator.gd</files>
  <action>
Create new directory Scripts/generation/ if it doesn't exist.

Create MovieGenerator class (extends RefCounted):

```gdscript
class_name MovieGenerator
extends RefCounted

const GENRES := ["Action", "Comedy", "Drama", "Horror", "Sci-Fi", "Romance", "Thriller", "Animation"]

const TITLE_ADJECTIVES := ["The Great", "Dark", "Lost", "Final", "Secret", "Eternal", "Hidden", "Last", "Midnight", "Golden", "Silver", "Crimson", "Frozen", "Burning", "Silent"]

const TITLE_NOUNS := ["Journey", "Mystery", "Kingdom", "Storm", "Heart", "Shadow", "Legend", "Dawn", "Empire", "Quest", "Dreams", "Destiny", "Secrets", "Paradise", "Horizon"]

var rng: RandomNumberGenerator
var _id_counter: int = 0
```

Implement methods:

1. `_init()` - Create RNG instance, seed with current time

2. `generate_movie() -> MovieResource`:
   - Create new MovieResource
   - id: "movie_%d_%d" % [Time.get_unix_time_from_system(), _id_counter]; increment _id_counter
   - title: _generate_title()
   - genre: GENRES[rng.randi_range(0, GENRES.size() - 1)]
   - rating: rng.randi_range(30, 100) - never below 30 (avoid terrible movies)
   - duration: rng.randi_range(80, 180) - standard movie length range

3. `_generate_title() -> String`:
   - Pick random adjective and noun
   - Return "%s %s" % [adj, noun]

4. `generate_pool(count: int = 0) -> Array[MovieResource]`:
   - If count <= 0, use rng.randi_range(5, 8) for default pool size
   - Generate count movies
   - Return typed array

5. `set_seed(seed_value: int)`:
   - rng.seed = seed_value
   - Reset _id_counter to 0
   - Allows reproducible generation for testing

Use RandomNumberGenerator instance (NOT global randi()) for reproducibility.
  </action>
  <verify>
Test in Godot console:
```gdscript
var gen = MovieGenerator.new()
gen.set_seed(12345)
var movie = gen.generate_movie()
print(movie.title, " - ", movie.genre, " - ", movie.rating, " - ", movie.duration)
var pool = gen.generate_pool(5)
print("Pool size: ", pool.size())
```
Should produce consistent output with same seed.
  </verify>
  <done>
MovieGenerator can create varied movies with unique IDs, random titles/genres/ratings/durations. Pool generation produces 5-8 movies by default.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MoviePool and MoviePoolSerializer</name>
  <files>Scripts/storage/MoviePool.gd, Scripts/storage/MoviePoolSerializer.gd</files>
  <action>
Create MoviePool class (extends RefCounted):

```gdscript
class_name MoviePool
extends RefCounted

var available_movies: Array[MovieResource] = []
```

Implement methods:

1. `add_movie(movie: MovieResource)` - Append to available_movies

2. `remove_movie(movie_id: String) -> bool`:
   - Find movie by id, remove from array
   - Return true if found and removed

3. `get_movie(movie_id: String) -> MovieResource`:
   - Find and return movie by id, or null if not found

4. `get_all_movies() -> Array[MovieResource]`:
   - Return duplicate of available_movies array

5. `size() -> int`:
   - Return available_movies.size()

6. `to_dict() -> Dictionary`:
   - Return {"movies": [array of movie.to_dict()]}

7. `static func from_dict(data: Dictionary) -> MoviePool`:
   - Create new MoviePool
   - Clear available_movies, re-append from data (preserve typed array)
   - Use MovieResource.from_dict() for each movie entry
   - Handle missing/empty data gracefully

---

Create MoviePoolSerializer class (extends RefCounted) following RoomSerializer pattern:

```gdscript
class_name MoviePoolSerializer
extends RefCounted

const SAVE_PATH := "user://saves/movie_pool.json"
const TEMP_PATH := "user://saves/movie_pool.json.tmp"
const SAVE_DIR := "user://saves"
const SCHEMA_VERSION := 1
```

Implement static methods:

1. `static func save_pool(pool: MoviePool) -> bool`:
   - Ensure SAVE_DIR exists (DirAccess.make_dir_recursive_absolute)
   - Build save_data dict with version, saved_at timestamp, pool.to_dict()
   - JSON.stringify with "  " indent
   - Atomic write: write to TEMP_PATH, then rename to SAVE_PATH
   - Return true on success, false with push_error on failure

2. `static func load_pool() -> MoviePool`:
   - Return null if file doesn't exist
   - Read file, parse JSON
   - Version check (warn if newer, proceed)
   - Return MoviePool.from_dict(data.pool)

3. `static func exists() -> bool`:
   - Return FileAccess.file_exists(SAVE_PATH)

Follow the atomic write pattern from RoomSerializer.gd exactly.
  </action>
  <verify>
Test in Godot console:
```gdscript
var gen = MovieGenerator.new()
var pool = MoviePool.new()
for movie in gen.generate_pool(5):
    pool.add_movie(movie)
print("Pool has ", pool.size(), " movies")
var saved = MoviePoolSerializer.save_pool(pool)
print("Saved: ", saved)
var loaded = MoviePoolSerializer.load_pool()
print("Loaded pool has ", loaded.size(), " movies")
```
Verify file exists at user://saves/movie_pool.json.
  </verify>
  <done>
MoviePool stores and retrieves movies by ID. MoviePoolSerializer saves/loads atomically with proper error handling. Round-trip serialization preserves all movie data.
  </done>
</task>

</tasks>

<verification>
1. All three scripts load without errors
2. MovieGenerator produces different movies on each call (without set_seed)
3. MovieGenerator produces same movies with same seed
4. MoviePool.to_dict() -> MoviePool.from_dict() round-trips correctly
5. MoviePoolSerializer creates file at user://saves/movie_pool.json
6. Loaded pool contains same movies as saved pool
</verification>

<success_criteria>
- [ ] MovieGenerator.gd exists at Scripts/generation/MovieGenerator.gd
- [ ] MoviePool.gd exists at Scripts/storage/MoviePool.gd
- [ ] MoviePoolSerializer.gd exists at Scripts/storage/MoviePoolSerializer.gd
- [ ] Generator produces varied movies with unique IDs
- [ ] Pool serialization round-trips without data loss
- [ ] Serializer uses atomic write pattern
- [ ] No Godot parser errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-movie-data-system/12-02-SUMMARY.md`
</output>
