---
phase: 05-furniture-editing-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/room_editing/FurnitureEditController.gd
  - scripts/storage/RoomInstance.gd
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Dragging selected furniture moves it to a new position"
    - "Furniture snaps to grid during drag"
    - "Dragging furniture to invalid position reverts to original position"
    - "Moving furniture triggers auto-save via placement_changed signal"
  artifacts:
    - path: "scripts/room_editing/FurnitureEditController.gd"
      provides: "Drag state machine with motion event handling"
      contains: "_dragging"
    - path: "scripts/storage/RoomInstance.gd"
      provides: "FurniturePlacement.visual_node reference for position updates"
      contains: "visual_node"
  key_links:
    - from: "FurnitureEditController._update_drag_position"
      to: "CollisionOperation.can_place_furniture"
      via: "validation before position update"
      pattern: "can_place_furniture"
    - from: "FurnitureEditController._end_drag"
      to: "RoomInstance.placement_changed"
      via: "signal emission after successful move"
      pattern: "placement_changed\\.emit"
---

<objective>
Implement furniture drag-to-move functionality in FurnitureEditController.

Purpose: Enable players to reposition furniture within rooms by dragging, the core interaction of FUR-03.

Output: FurnitureEditController extended with drag state machine, motion event handling, and validated position updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-furniture-editing-operations/05-RESEARCH.md
@scripts/room_editing/FurnitureEditController.gd
@scripts/storage/RoomInstance.gd
@scripts/room_building/operations/CollisionOperation.gd
@scripts/RoomManager.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add drag state tracking to FurnitureEditController</name>
  <files>scripts/room_editing/FurnitureEditController.gd</files>
  <action>
Add drag state variables and constants to FurnitureEditController:

1. Add state variables after existing tap detection state (around line 25):
```gdscript
# Drag state
var _dragging: bool = false
var _drag_start_tile: Vector2i = Vector2i.ZERO
var _drag_offset: Vector2i = Vector2i.ZERO  # Offset from furniture position to tap point
var _preview_position: Vector2i = Vector2i.ZERO
var _preview_valid: bool = false
var _original_position: Vector2i = Vector2i.ZERO  # For revert on invalid drop

# Operation helpers
var _collision_operation: CollisionOperation = null
```

2. Add signal for drag preview (for FurnitureSelectionHighlight to subscribe):
```gdscript
signal furniture_drag_preview(position: Vector2i, is_valid: bool)
signal furniture_drag_ended
```

3. Initialize _collision_operation in enter_edit_mode():
```gdscript
if _collision_operation == null:
    _collision_operation = CollisionOperation.new()
```

4. Add helper method to convert screen position to tile:
```gdscript
func _screen_to_tile(screen_pos: Vector2) -> Vector2i:
    return IsometricMath.screen_to_tile(screen_pos, get_viewport())
```
  </action>
  <verify>
Run `grep -n "_dragging\|_drag_offset\|_collision_operation\|furniture_drag_preview" scripts/room_editing/FurnitureEditController.gd` shows all new variables and signals.
  </verify>
  <done>FurnitureEditController has drag state variables, drag preview signal, and CollisionOperation reference.</done>
</task>

<task type="auto">
  <name>Task 2: Implement drag detection and motion handling</name>
  <files>scripts/room_editing/FurnitureEditController.gd</files>
  <action>
Modify _on_furniture_input to transition from tap to drag on motion threshold, and handle motion events:

1. Update _on_furniture_input (lines 187-212) to track drag start on press and check for drag transition on release:

For mouse button handling, change the else block (release) to:
```gdscript
else:
    if _dragging:
        _end_drag()
    else:
        var distance: float = event.position.distance_to(_touch_start_pos)
        var duration := Time.get_ticks_msec() - _touch_start_time
        if distance < TAP_DISTANCE_THRESHOLD and duration < TAP_TIME_THRESHOLD:
            _select_furniture(furn)
```

Add motion event handling in the same function, after touch handling:
```gdscript
# Handle mouse motion for drag (desktop)
if event is InputEventMouseMotion:
    if _selected_furniture != null and _touch_start_pos != Vector2.ZERO:
        var distance = event.position.distance_to(_touch_start_pos)
        if distance >= TAP_DISTANCE_THRESHOLD and not _dragging:
            _start_drag()
        if _dragging:
            _update_drag_position(event.position)
    return

# Handle touch drag (mobile)
if event is InputEventScreenDrag:
    if _selected_furniture != null and not _dragging:
        _start_drag()
    if _dragging:
        _update_drag_position(event.position)
```

2. Add the drag state transition methods:
```gdscript
func _start_drag() -> void:
    if _selected_furniture == null:
        return
    _dragging = true
    _original_position = _selected_furniture.position
    _drag_start_tile = _screen_to_tile(_touch_start_pos)
    _drag_offset = _drag_start_tile - _selected_furniture.position
    _preview_position = _selected_furniture.position
    _preview_valid = true


func _update_drag_position(screen_pos: Vector2) -> void:
    if not _dragging or _selected_furniture == null:
        return

    var cursor_tile = _screen_to_tile(screen_pos)
    var new_position = cursor_tile - _drag_offset

    # Skip if position unchanged
    if new_position == _preview_position:
        return

    # Temporarily remove this furniture from room to avoid self-collision
    var furniture_index = _current_room.furniture.find(_selected_furniture)
    var temp_removed = false
    if furniture_index >= 0:
        _current_room.furniture.remove_at(furniture_index)
        temp_removed = true

    # Validate new position
    var result = _collision_operation.can_place_furniture(
        _selected_furniture.furniture,
        new_position,
        _selected_furniture.rotation,
        _current_room
    )

    # Restore furniture to array
    if temp_removed:
        _current_room.furniture.insert(furniture_index, _selected_furniture)

    _preview_position = new_position
    _preview_valid = result.can_place
    furniture_drag_preview.emit(_preview_position, _preview_valid)


func _end_drag() -> void:
    if not _dragging:
        return

    _dragging = false

    if _preview_valid and _preview_position != _original_position:
        # Commit the move
        _selected_furniture.position = _preview_position

        # Update visual node position if it exists
        if _selected_furniture.visual_node and is_instance_valid(_selected_furniture.visual_node):
            var world_pos = IsometricMath.tile_to_world(_preview_position)
            _selected_furniture.visual_node.position = world_pos

        # Trigger auto-save
        _current_room.placement_changed.emit()

    # Reset drag state
    _touch_start_pos = Vector2.ZERO
    furniture_drag_ended.emit()
```

Important: The _start_drag call should only happen when furniture is selected. Add check at start of _on_furniture_input to store selected furniture reference on press:
```gdscript
# At the start of press handling (after setting _touch_start_pos):
if event.pressed and furn == _selected_furniture:
    pass  # Already selected, can start drag
elif event.pressed:
    # First press - just track for tap detection
    pass
```
  </action>
  <verify>
Run the game, enter furniture edit mode on a room with furniture:
1. Tap furniture to select (cyan highlight appears)
2. Press and drag furniture - should see it following cursor
3. Release on valid position - furniture stays at new position
4. Release on invalid position (wall/outside) - furniture returns to original position
  </verify>
  <done>Furniture can be dragged to new positions with tap-vs-drag detection working correctly.</done>
</task>

<task type="auto">
  <name>Task 3: Add visual_node tracking to FurniturePlacement</name>
  <files>scripts/storage/RoomInstance.gd, scripts/room_building/operations/FurnitureOperation.gd</files>
  <action>
1. Add visual_node property to FurniturePlacement class in RoomInstance.gd (around line 36):
```gdscript
var visual_node: Node2D = null  # Reference to visual node for position updates and cleanup
```

2. Add cleanup helper method to FurniturePlacement:
```gdscript
func cleanup_visual() -> void:
    if visual_node and is_instance_valid(visual_node):
        visual_node.queue_free()
    visual_node = null
```

3. Update FurnitureOperation.create_furniture_visual to store the reference (after line 14 where node is created):
```gdscript
# In _setup_furniture_instance, before return:
placement.visual_node = instance
return instance
```

Also update the placeholder path (around line 22):
```gdscript
placement.visual_node = placeholder
return placeholder
```

Note: to_dict() and from_dict() should NOT serialize visual_node - it's a runtime reference only.
  </action>
  <verify>
Run `grep -n "visual_node" scripts/storage/RoomInstance.gd scripts/room_building/operations/FurnitureOperation.gd` shows the new property and assignments.
  </verify>
  <done>FurniturePlacement tracks visual_node reference for position updates and cleanup.</done>
</task>

</tasks>

<verification>
1. FurnitureEditController has drag state variables (_dragging, _drag_offset, etc.)
2. FurnitureEditController has furniture_drag_preview and furniture_drag_ended signals
3. FurnitureEditController._on_furniture_input handles InputEventMouseMotion and InputEventScreenDrag
4. FurniturePlacement has visual_node property
5. FurnitureOperation stores visual_node reference when creating furniture
6. Dragging furniture emits placement_changed signal (triggers auto-save)
</verification>

<success_criteria>
1. Selected furniture can be dragged by pressing and moving past TAP_DISTANCE_THRESHOLD
2. Quick tap still selects furniture (no drag transition)
3. Furniture position updates on drag end if placement is valid
4. Invalid placements revert to original position
5. placement_changed signal fires after successful move (enables auto-save)
</success_criteria>

<output>
After completion, create `.planning/phases/05-furniture-editing-operations/05-01-SUMMARY.md`
</output>
