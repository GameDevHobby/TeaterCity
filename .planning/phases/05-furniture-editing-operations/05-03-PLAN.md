---
phase: 05-furniture-editing-operations
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/room_editing/FurnitureEditController.gd
  - scripts/room_editing/FurnitureListPanel.gd
  - scripts/room_building/operations/ValidationOperation.gd
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Delete button appears in list panel when furniture is selected"
    - "Deleting furniture removes visual node from scene"
    - "Deleting required furniture is blocked with error message"
    - "Deleting furniture triggers auto-save"
  artifacts:
    - path: "scripts/room_editing/FurnitureListPanel.gd"
      provides: "Delete button UI"
      contains: "_delete_button"
    - path: "scripts/room_editing/FurnitureEditController.gd"
      provides: "delete_furniture method with validation"
      contains: "delete_furniture"
    - path: "scripts/room_building/operations/ValidationOperation.gd"
      provides: "can_delete_furniture validation method"
      contains: "can_delete_furniture"
  key_links:
    - from: "FurnitureListPanel._on_delete_pressed"
      to: "FurnitureEditController.delete_furniture"
      via: "signal emission"
      pattern: "furniture_delete_requested"
    - from: "FurnitureEditController.delete_furniture"
      to: "ValidationOperation.can_delete_furniture"
      via: "validation before delete"
      pattern: "can_delete_furniture"
---

<objective>
Implement furniture delete operation with validation against room type requirements.

Purpose: Enable players to remove optional furniture while enforcing room type minimum requirements (FUR-05).

Output: Delete button in list panel, delete_furniture method in controller, validation in ValidationOperation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-furniture-editing-operations/05-RESEARCH.md
@scripts/room_editing/FurnitureEditController.gd
@scripts/room_editing/FurnitureListPanel.gd
@scripts/room_building/operations/ValidationOperation.gd
@scripts/storage/RoomInstance.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add can_delete_furniture validation to ValidationOperation</name>
  <files>scripts/room_building/operations/ValidationOperation.gd</files>
  <action>
Add a method to check if specific furniture can be deleted without violating room type requirements:

```gdscript
## Check if deleting this furniture placement would violate room type requirements
## Returns { can_delete: bool, reason: String }
func can_delete_furniture(room: RoomInstance, furniture: RoomInstance.FurniturePlacement) -> Dictionary:
    var result = { "can_delete": true, "reason": "" }

    if not furniture or not furniture.furniture:
        return result  # Can always delete null/invalid furniture

    var room_type_registry = RoomTypeRegistry.get_instance()
    var room_type = room_type_registry.get_room_type(room.room_type_id)

    if not room_type:
        return result  # Can delete if room type unknown

    # Check if this furniture type is required
    for req in room_type.get_required_furniture():
        if not req.furniture:
            continue

        if req.furniture == furniture.furniture:
            # This furniture type is required - check count
            var current_count = room.get_furniture_count_by_resource(req.furniture)
            if current_count <= req.count:
                var display_name = req.furniture.name if req.furniture.name else req.furniture.id
                result.can_delete = false
                result.reason = "Cannot delete: %s is required (minimum %d)" % [display_name, req.count]
                return result

    return result
```
  </action>
  <verify>
Run `grep -n "can_delete_furniture" scripts/room_building/operations/ValidationOperation.gd` shows the new method.
  </verify>
  <done>ValidationOperation has can_delete_furniture method that checks room type requirements.</done>
</task>

<task type="auto">
  <name>Task 2: Add delete_furniture method to FurnitureEditController</name>
  <files>scripts/room_editing/FurnitureEditController.gd</files>
  <action>
1. Add signal for delete result (after existing signals):
```gdscript
signal furniture_deleted(room: RoomInstance, furniture: RoomInstance.FurniturePlacement)
signal furniture_delete_failed(reason: String)
```

2. Add ValidationOperation reference (after _collision_operation declaration):
```gdscript
var _validation_operation: ValidationOperation = null
```

3. Initialize in enter_edit_mode (after _collision_operation initialization):
```gdscript
if _validation_operation == null:
    _validation_operation = ValidationOperation.new()
```

4. Add delete_furniture public method:
```gdscript
## Attempt to delete the currently selected furniture
## Returns true if deletion succeeded, false if blocked
func delete_furniture() -> bool:
    if not _active or _current_room == null or _selected_furniture == null:
        return false

    # Validate deletion against room type requirements
    var validation = _validation_operation.can_delete_furniture(_current_room, _selected_furniture)
    if not validation.can_delete:
        furniture_delete_failed.emit(validation.reason)
        return false

    # Store reference before clearing selection
    var deleted_furniture = _selected_furniture
    var furniture_index = _current_room.furniture.find(deleted_furniture)

    # Clear selection first
    _selected_furniture = null
    furniture_deselected.emit()

    # Remove Area2D for this furniture
    if _furniture_areas.has(furniture_index):
        var area = _furniture_areas[furniture_index]
        if area and is_instance_valid(area):
            area.queue_free()
        _furniture_areas.erase(furniture_index)

    # Cleanup visual node
    if deleted_furniture.visual_node and is_instance_valid(deleted_furniture.visual_node):
        deleted_furniture.visual_node.queue_free()
    deleted_furniture.visual_node = null

    # Remove from room's furniture array
    if furniture_index >= 0:
        _current_room.furniture.remove_at(furniture_index)

    # Trigger auto-save
    _current_room.placement_changed.emit()

    # Emit deleted signal
    furniture_deleted.emit(_current_room, deleted_furniture)

    # Recreate furniture areas with updated indices
    _recreate_furniture_areas()

    return true


func _recreate_furniture_areas() -> void:
    # Clear all existing areas
    _clear_furniture_areas()
    # Recreate with current furniture
    if _current_room:
        _create_furniture_areas(_current_room)
```
  </action>
  <verify>
Run `grep -n "delete_furniture\|furniture_deleted\|furniture_delete_failed" scripts/room_editing/FurnitureEditController.gd` shows the new method and signals.
  </verify>
  <done>FurnitureEditController has delete_furniture method with validation and cleanup.</done>
</task>

<task type="auto">
  <name>Task 3: Add delete button to FurnitureListPanel</name>
  <files>scripts/room_editing/FurnitureListPanel.gd</files>
  <action>
1. Add signal for delete request (after existing signals):
```gdscript
signal furniture_delete_requested
```

2. Add delete button variable (after _done_button):
```gdscript
var _delete_button: Button
var _error_label: Label  # For showing delete error messages
```

3. Create delete button in _create_panel (after done button creation, around line 86):
```gdscript
# Delete button (hidden until furniture selected)
_delete_button = UIStyleHelper.create_styled_button("Delete", Vector2(160, 40), Color(0.6, 0.2, 0.2))
_delete_button.pressed.connect(_on_delete_pressed)
_delete_button.hide()  # Hidden until selection
vbox.add_child(_delete_button)

# Error label for delete failures
_error_label = Label.new()
_error_label.add_theme_color_override("font_color", Color(0.9, 0.3, 0.3))
_error_label.add_theme_font_size_override("font_size", 12)
_error_label.autowrap_mode = TextServer.AUTOWRAP_WORD
_error_label.custom_minimum_size = Vector2(160, 0)
_error_label.hide()
vbox.add_child(_error_label)
```

4. Update select_item to show/hide delete button:
```gdscript
func select_item(index: int) -> void:
    # ... existing unhighlight code ...

    _selected_index = index

    # Show/hide delete button based on selection
    if index >= 0:
        _delete_button.show()
        _error_label.hide()  # Clear any previous error
    else:
        _delete_button.hide()
        _error_label.hide()

    # ... existing highlight and scroll code ...
```

5. Add delete button handler:
```gdscript
func _on_delete_pressed() -> void:
    furniture_delete_requested.emit()
```

6. Connect to controller delete signals in set_controller (after existing connections):
```gdscript
_controller.furniture_deleted.connect(_on_controller_furniture_deleted)
_controller.furniture_delete_failed.connect(_on_controller_furniture_delete_failed)
```

7. Add handlers for delete signals:
```gdscript
func _on_controller_furniture_deleted(room: RoomInstance, _furniture: RoomInstance.FurniturePlacement) -> void:
    # Refresh the list
    _populate_list(room)
    _selected_index = -1
    _delete_button.hide()
    _error_label.hide()


func _on_controller_furniture_delete_failed(reason: String) -> void:
    _error_label.text = reason
    _error_label.show()
```
  </action>
  <verify>
Run the game, enter furniture edit mode:
1. Select furniture - delete button appears (red)
2. Deselect - delete button hides
3. Select required furniture and tap delete - error message shows
4. Select optional furniture and tap delete - furniture disappears from list and room
  </verify>
  <done>FurnitureListPanel has delete button that shows when furniture is selected and handles delete results.</done>
</task>

</tasks>

<verification>
1. ValidationOperation.can_delete_furniture returns can_delete: false for required furniture at minimum count
2. ValidationOperation.can_delete_furniture returns can_delete: true for optional furniture
3. FurnitureEditController.delete_furniture cleans up visual_node and Area2D
4. FurnitureEditController.delete_furniture emits placement_changed for auto-save
5. FurnitureListPanel shows delete button when furniture selected
6. FurnitureListPanel shows error message when delete blocked
</verification>

<success_criteria>
1. Delete button visible when furniture is selected
2. Deleting optional furniture removes it from room and refreshes list
3. Deleting required furniture at minimum count shows error, furniture remains
4. Deleted furniture's visual node is removed from scene
5. placement_changed signal fires after successful delete (triggers auto-save)
</success_criteria>

<output>
After completion, create `.planning/phases/05-furniture-editing-operations/05-03-SUMMARY.md`
</output>
