---
phase: 05-furniture-editing-operations
plan: 04
type: execute
wave: 2
depends_on: ["05-03"]
files_modified:
  - scripts/room_editing/FurnitureEditController.gd
  - scripts/room_editing/FurnitureListPanel.gd
  - scripts/Main.gd
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Add button in list panel opens furniture picker"
    - "Furniture picker shows allowed furniture for room type"
    - "Selecting furniture enters placement mode"
    - "Tapping valid position places furniture"
    - "Adding furniture triggers auto-save"
  artifacts:
    - path: "scripts/room_editing/FurnitureListPanel.gd"
      provides: "Add button and furniture picker UI"
      contains: "_add_button"
    - path: "scripts/room_editing/FurnitureEditController.gd"
      provides: "Placement mode state and add_furniture method"
      contains: "_placement_mode"
  key_links:
    - from: "FurnitureListPanel._on_add_pressed"
      to: "furniture_add_requested signal"
      via: "signal emission"
      pattern: "furniture_add_requested"
    - from: "FurnitureEditController.confirm_placement"
      to: "RoomInstance.add_furniture"
      via: "method call on valid placement"
      pattern: "add_furniture"
---

<objective>
Implement furniture add operation with placement mode and room type constraints.

Purpose: Enable players to add new furniture to rooms within room type constraints (FUR-04).

Output: Add button in list panel, furniture picker overlay, placement mode in controller with validation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-furniture-editing-operations/05-RESEARCH.md
@.planning/phases/05-furniture-editing-operations/05-03-PLAN.md
@scripts/room_editing/FurnitureEditController.gd
@scripts/room_editing/FurnitureListPanel.gd
@scripts/room_building/RoomBuildUI.gd
@scripts/Main.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add placement mode state to FurnitureEditController</name>
  <files>scripts/room_editing/FurnitureEditController.gd</files>
  <action>
1. Add placement mode signals (after existing signals):
```gdscript
signal placement_mode_entered(furniture: FurnitureResource)
signal placement_mode_exited
signal furniture_added(room: RoomInstance, furniture: RoomInstance.FurniturePlacement)
signal placement_preview_updated(position: Vector2i, is_valid: bool)
```

2. Add placement mode state (after drag state variables):
```gdscript
# Placement mode state (for adding new furniture)
var _placement_mode: bool = false
var _placement_furniture: FurnitureResource = null
var _placement_rotation: int = 0
var _placement_preview_pos: Vector2i = Vector2i.ZERO
var _placement_preview_valid: bool = false
```

3. Add FurnitureOperation reference and initialize (after _validation_operation):
```gdscript
var _furniture_operation: FurnitureOperation = null

# In enter_edit_mode:
if _furniture_operation == null:
    _furniture_operation = FurnitureOperation.new()
```

4. Add placement mode methods:
```gdscript
func enter_placement_mode(furniture: FurnitureResource) -> void:
    if not _active or _current_room == null:
        return

    # Clear any existing selection
    if _selected_furniture != null:
        _selected_furniture = null
        furniture_deselected.emit()

    _placement_mode = true
    _placement_furniture = furniture
    _placement_rotation = 0
    _placement_preview_pos = Vector2i.ZERO
    _placement_preview_valid = false

    placement_mode_entered.emit(furniture)


func exit_placement_mode() -> void:
    _placement_mode = false
    _placement_furniture = null
    _placement_rotation = 0
    placement_mode_exited.emit()


func rotate_placement() -> void:
    if not _placement_mode:
        return
    _placement_rotation = (_placement_rotation + 1) % 4
    # Re-validate at current position
    if _placement_preview_pos != Vector2i.ZERO:
        _update_placement_preview(_placement_preview_pos)


func is_in_placement_mode() -> bool:
    return _placement_mode


func get_placement_furniture() -> FurnitureResource:
    return _placement_furniture


func get_placement_rotation() -> int:
    return _placement_rotation


func _update_placement_preview(tile_pos: Vector2i) -> void:
    _placement_preview_pos = tile_pos

    var result = _collision_operation.can_place_furniture(
        _placement_furniture,
        tile_pos,
        _placement_rotation,
        _current_room
    )

    _placement_preview_valid = result.can_place
    placement_preview_updated.emit(tile_pos, _placement_preview_valid)


func confirm_placement() -> bool:
    if not _placement_mode or _placement_furniture == null:
        return false

    if not _placement_preview_valid:
        return false

    # Add furniture to room
    var placement = RoomInstance.FurniturePlacement.new(
        _placement_furniture,
        _placement_preview_pos,
        _placement_rotation
    )
    _current_room.furniture.append(placement)

    # Create visual node (need tilemap reference from Main)
    # For now, we'll emit signal and let Main handle visual creation
    furniture_added.emit(_current_room, placement)

    # Trigger auto-save
    _current_room.placement_changed.emit()

    # Exit placement mode
    exit_placement_mode()

    # Recreate furniture areas to include new furniture
    _recreate_furniture_areas()

    return true
```

5. Update _input handling to support placement mode. Add to _unhandled_input (before existing tap handling):
```gdscript
# Handle placement mode input
if _placement_mode:
    # Track mouse/touch position for preview
    if event is InputEventMouseMotion:
        var tile_pos = _screen_to_tile(event.position)
        _update_placement_preview(tile_pos)

    if event is InputEventScreenDrag:
        var tile_pos = _screen_to_tile(event.position)
        _update_placement_preview(tile_pos)

    # Handle tap to place
    if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
        if event.pressed:
            var tile_pos = _screen_to_tile(event.position)
            _update_placement_preview(tile_pos)
        else:
            if _placement_preview_valid:
                confirm_placement()
                get_viewport().set_input_as_handled()
        return

    if event is InputEventScreenTouch:
        if event.pressed:
            var tile_pos = _screen_to_tile(event.position)
            _update_placement_preview(tile_pos)
        else:
            if _placement_preview_valid:
                confirm_placement()
                get_viewport().set_input_as_handled()
        return
```
  </action>
  <verify>
Run `grep -n "_placement_mode\|enter_placement_mode\|confirm_placement\|furniture_added" scripts/room_editing/FurnitureEditController.gd` shows new methods and signals.
  </verify>
  <done>FurnitureEditController has placement mode state, entry/exit methods, and confirm_placement logic.</done>
</task>

<task type="auto">
  <name>Task 2: Add furniture picker UI to FurnitureListPanel</name>
  <files>scripts/room_editing/FurnitureListPanel.gd</files>
  <action>
1. Add signals (after existing signals):
```gdscript
signal furniture_add_requested  # Request to show picker
signal furniture_selected_for_add(furniture: FurnitureResource)  # Furniture chosen from picker
signal placement_cancelled
```

2. Add UI state variables (after _error_label):
```gdscript
var _add_button: Button
var _picker_panel: PanelContainer = null  # Furniture picker overlay
var _picker_buttons: Array[Button] = []
var _cancel_add_button: Button = null
var _rotate_button: Button = null
```

3. Create add button in _create_panel (before done button, to put it above):
```gdscript
# Add button (for adding new furniture)
_add_button = UIStyleHelper.create_styled_button("+ Add Furniture", Vector2(160, 40), Color(0.2, 0.4, 0.3))
_add_button.pressed.connect(_on_add_pressed)
vbox.add_child(_add_button)
```

4. Add picker creation method:
```gdscript
func _create_picker_panel(room: RoomInstance) -> void:
    if _picker_panel != null:
        _picker_panel.queue_free()

    _picker_panel = PanelContainer.new()
    _picker_panel.name = "FurniturePicker"
    _picker_panel.mouse_filter = MOUSE_FILTER_STOP
    UIStyleHelper.apply_panel_style(_picker_panel)
    add_child(_picker_panel)

    # Position above the list panel
    _picker_panel.set_anchors_preset(PRESET_BOTTOM_LEFT)
    _picker_panel.position = Vector2(PANEL_MARGIN, -PANEL_MARGIN - 300)  # Above list panel
    _picker_panel.custom_minimum_size = Vector2(PANEL_WIDTH, 150)

    var margin := MarginContainer.new()
    margin.add_theme_constant_override("margin_left", 12)
    margin.add_theme_constant_override("margin_right", 12)
    margin.add_theme_constant_override("margin_top", 12)
    margin.add_theme_constant_override("margin_bottom", 12)
    _picker_panel.add_child(margin)

    var vbox := VBoxContainer.new()
    vbox.add_theme_constant_override("separation", 4)
    margin.add_child(vbox)

    # Title
    var title := Label.new()
    title.text = "Select Furniture"
    title.add_theme_color_override("font_color", UIStyleHelper.DEFAULT_FONT_COLOR)
    vbox.add_child(title)

    # Get room type for allowed furniture
    var room_type = RoomTypeRegistry.get_instance().get_room_type(room.room_type_id)
    if room_type:
        _populate_picker_buttons(vbox, room_type)

    # Cancel button
    _cancel_add_button = UIStyleHelper.create_styled_button("Cancel", Vector2(160, 36))
    _cancel_add_button.pressed.connect(_on_cancel_add_pressed)
    vbox.add_child(_cancel_add_button)


func _populate_picker_buttons(container: VBoxContainer, room_type: RoomTypeResource) -> void:
    _picker_buttons.clear()

    # Add all allowed furniture as buttons
    var all_furniture: Array[FurnitureResource] = []

    # Add required furniture
    for req in room_type.get_required_furniture():
        if req.furniture and req.furniture not in all_furniture:
            all_furniture.append(req.furniture)

    # Add optional allowed furniture
    for furn in room_type.allowed_furniture:
        if furn not in all_furniture:
            all_furniture.append(furn)

    for furn in all_furniture:
        var display_name = furn.name if furn.name else furn.id
        var btn = UIStyleHelper.create_styled_button(display_name, Vector2(160, 36))
        btn.pressed.connect(_on_picker_furniture_selected.bind(furn))
        container.add_child(btn)
        _picker_buttons.append(btn)


func _hide_picker() -> void:
    if _picker_panel != null:
        _picker_panel.queue_free()
        _picker_panel = null
    _picker_buttons.clear()
```

5. Add button handlers:
```gdscript
func _on_add_pressed() -> void:
    if _current_room == null:
        return
    _create_picker_panel(_current_room)
    furniture_add_requested.emit()


func _on_cancel_add_pressed() -> void:
    _hide_picker()
    placement_cancelled.emit()


func _on_picker_furniture_selected(furniture: FurnitureResource) -> void:
    _hide_picker()
    furniture_selected_for_add.emit(furniture)
```

6. Update show_for_room to store room reference:
```gdscript
# Already stores _current_room = room
```

7. Connect to controller placement signals in set_controller:
```gdscript
_controller.placement_mode_exited.connect(_on_controller_placement_exited)
_controller.furniture_added.connect(_on_controller_furniture_added)
```

8. Add handlers:
```gdscript
func _on_controller_placement_exited() -> void:
    _hide_picker()


func _on_controller_furniture_added(room: RoomInstance, _furniture: RoomInstance.FurniturePlacement) -> void:
    # Refresh the list with new furniture
    _populate_list(room)
```
  </action>
  <verify>
Run `grep -n "_add_button\|_picker_panel\|furniture_selected_for_add" scripts/room_editing/FurnitureListPanel.gd` shows new UI elements and signals.
  </verify>
  <done>FurnitureListPanel has add button and furniture picker overlay UI.</done>
</task>

<task type="auto">
  <name>Task 3: Wire up Main.gd for placement mode and visual creation</name>
  <files>scripts/Main.gd</files>
  <action>
1. Connect list panel add signals (after existing signal connections around line 79):
```gdscript
_furniture_list_panel.furniture_selected_for_add.connect(_on_furniture_selected_for_add)
_furniture_list_panel.placement_cancelled.connect(_on_placement_cancelled)
```

2. Connect controller placement signals:
```gdscript
_furniture_controller.furniture_added.connect(_on_furniture_added)
_furniture_controller.placement_preview_updated.connect(_on_placement_preview_updated)
```

3. Add handler for furniture selection from picker:
```gdscript
func _on_furniture_selected_for_add(furniture: FurnitureResource) -> void:
    _furniture_controller.enter_placement_mode(furniture)


func _on_placement_cancelled() -> void:
    _furniture_controller.exit_placement_mode()
```

4. Add handler for furniture added (creates visual node):
```gdscript
func _on_furniture_added(room: RoomInstance, placement: RoomInstance.FurniturePlacement) -> void:
    # Get tilemap layer from room build manager
    var tilemap_layer = room_build_manager.get_tilemap_layer()
    var furniture_parent = room_build_manager.get_furniture_parent()

    if tilemap_layer and furniture_parent:
        var furniture_op = FurnitureOperation.new()
        furniture_op.create_furniture_visual(placement, furniture_parent, tilemap_layer)

    print("Furniture added: ", placement.furniture.name if placement.furniture else "unknown")
```

5. Add placeholder handler for placement preview (FurnitureSelectionHighlight will handle the actual drawing):
```gdscript
func _on_placement_preview_updated(_position: Vector2i, _is_valid: bool) -> void:
    # FurnitureSelectionHighlight handles visual preview via its own signal connection
    pass
```

Note: You'll need to add helper methods to RoomBuildController to expose tilemap_layer and furniture_parent. Add these to RoomBuildController.gd if they don't exist:
```gdscript
func get_tilemap_layer() -> TileMapLayer:
    return tilemap_layer  # Or whatever the variable name is

func get_furniture_parent() -> Node2D:
    return furniture_parent  # Or the appropriate node
```
  </action>
  <verify>
Run `grep -n "_on_furniture_selected_for_add\|_on_furniture_added\|enter_placement_mode" scripts/Main.gd` shows the new handlers.
  </verify>
  <done>Main.gd wires up placement mode flow and handles furniture visual creation.</done>
</task>

</tasks>

<verification>
1. FurnitureEditController has enter_placement_mode, exit_placement_mode, confirm_placement methods
2. FurnitureListPanel has add button and furniture picker overlay
3. Main.gd connects list panel and controller signals for add flow
4. placement_changed signal fires after furniture_added (enables auto-save)
</verification>

<success_criteria>
1. Add button in list panel opens furniture picker
2. Picker shows all allowed furniture for room type
3. Selecting furniture from picker enters placement mode
4. Moving cursor shows placement preview (valid/invalid)
5. Tapping valid position places furniture and refreshes list
6. placement_changed signal fires (triggers auto-save)
</success_criteria>

<output>
After completion, create `.planning/phases/05-furniture-editing-operations/05-04-SUMMARY.md`
</output>
