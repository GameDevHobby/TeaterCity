---
phase: 05-furniture-editing-operations
plan: 05
type: execute
wave: 3
depends_on: ["05-02", "05-04"]
files_modified:
  - scripts/room_editing/FurnitureSelectionHighlight.gd
  - scripts/room_building/RoomBuildController.gd
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Placement mode shows ghost preview at cursor position"
    - "Valid placement positions show green preview"
    - "Invalid placement positions show red preview"
    - "RoomBuildController exposes tilemap_layer and furniture_parent"
  artifacts:
    - path: "scripts/room_editing/FurnitureSelectionHighlight.gd"
      provides: "Placement preview rendering"
      contains: "_draw_placement_preview"
    - path: "scripts/room_building/RoomBuildController.gd"
      provides: "Accessors for tilemap_layer and furniture_parent"
      contains: "get_tilemap_layer"
  key_links:
    - from: "FurnitureSelectionHighlight._on_placement_preview"
      to: "FurnitureEditController.placement_preview_updated"
      via: "signal connection"
      pattern: "placement_preview_updated\\.connect"
---

<objective>
Add placement preview visual feedback and expose RoomBuildController internals for furniture creation.

Purpose: Complete the add furniture visual feedback loop and enable visual creation from Main.gd.

Output: FurnitureSelectionHighlight renders placement preview, RoomBuildController has accessor methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-furniture-editing-operations/05-02-PLAN.md
@.planning/phases/05-furniture-editing-operations/05-04-PLAN.md
@scripts/room_editing/FurnitureSelectionHighlight.gd
@scripts/room_building/RoomBuildController.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add placement preview to FurnitureSelectionHighlight</name>
  <files>scripts/room_editing/FurnitureSelectionHighlight.gd</files>
  <action>
1. Add placement preview state (after drag preview state):
```gdscript
# Placement mode state (for adding new furniture)
var _in_placement_mode: bool = false
var _placement_preview_position: Vector2i = Vector2i.ZERO
var _placement_preview_valid: bool = false
```

2. Update set_controller to connect placement signals (add after drag signal connections):
```gdscript
if _controller.placement_mode_entered.is_connected(_on_placement_mode_entered):
    _controller.placement_mode_entered.disconnect(_on_placement_mode_entered)
if _controller.placement_mode_exited.is_connected(_on_placement_mode_exited):
    _controller.placement_mode_exited.disconnect(_on_placement_mode_exited)
if _controller.placement_preview_updated.is_connected(_on_placement_preview_updated):
    _controller.placement_preview_updated.disconnect(_on_placement_preview_updated)

# Then in new controller section:
_controller.placement_mode_entered.connect(_on_placement_mode_entered)
_controller.placement_mode_exited.connect(_on_placement_mode_exited)
_controller.placement_preview_updated.connect(_on_placement_preview_updated)
```

3. Add signal handlers:
```gdscript
func _on_placement_mode_entered(_furniture: FurnitureResource) -> void:
    _in_placement_mode = true
    queue_redraw()


func _on_placement_mode_exited() -> void:
    _in_placement_mode = false
    queue_redraw()


func _on_placement_preview_updated(position: Vector2i, is_valid: bool) -> void:
    _placement_preview_position = position
    _placement_preview_valid = is_valid
    queue_redraw()
```

4. Update _draw() to handle placement mode (add before drag check):
```gdscript
func _draw() -> void:
    if _controller == null:
        return

    var viewport := get_viewport()

    # Placement mode preview (for adding new furniture)
    if _in_placement_mode:
        _draw_placement_preview(viewport)
        return

    # ... existing drag and selection code ...
```

5. Add placement preview drawing method:
```gdscript
func _draw_placement_preview(viewport: Viewport) -> void:
    var furniture := _controller.get_placement_furniture()
    if furniture == null:
        return

    var rotation := _controller.get_placement_rotation()

    # Get footprint tiles at preview position
    var preview_tiles := RotationHelper.get_footprint_tiles(
        _placement_preview_position,
        furniture.size,
        rotation
    )

    # Get access tiles at preview position
    var access_offsets := furniture.get_rotated_access_tiles(rotation)
    var preview_access_tiles: Array[Vector2i] = []
    for offset in access_offsets:
        preview_access_tiles.append(_placement_preview_position + offset)

    # Choose colors based on validity
    var tile_color: Color
    var access_color: Color
    if _placement_preview_valid:
        tile_color = DRAG_VALID_COLOR
        access_color = DRAG_ACCESS_VALID_COLOR
    else:
        tile_color = DRAG_INVALID_COLOR
        access_color = DRAG_ACCESS_INVALID_COLOR

    # Draw access tiles first
    for tile in preview_access_tiles:
        RoomBuildDrawing.draw_tile_highlight(self, tile, access_color, viewport)

    # Draw footprint tiles on top
    for tile in preview_tiles:
        RoomBuildDrawing.draw_tile_highlight(self, tile, tile_color, viewport)
```
  </action>
  <verify>
Run `grep -n "_in_placement_mode\|_draw_placement_preview\|placement_mode_entered" scripts/room_editing/FurnitureSelectionHighlight.gd` shows new state and methods.
  </verify>
  <done>FurnitureSelectionHighlight renders placement preview with valid/invalid colors.</done>
</task>

<task type="auto">
  <name>Task 2: Add accessor methods to RoomBuildController</name>
  <files>scripts/room_building/RoomBuildController.gd</files>
  <action>
First, read RoomBuildController to understand its structure and find the tilemap_layer and furniture parent variables.

Add accessor methods to expose tilemap_layer and furniture parent for external furniture creation:

```gdscript
## Get the tilemap layer for furniture tile operations
func get_tilemap_layer() -> TileMapLayer:
    return tilemap_layer  # Adjust variable name if different


## Get the parent node where furniture visuals should be added
func get_furniture_parent() -> Node2D:
    # If there's a dedicated furniture container, return it
    # Otherwise return the tilemap's parent or self
    if tilemap_layer:
        return tilemap_layer.get_parent() as Node2D
    return null
```

Note: The actual variable names in RoomBuildController may differ. Check the existing code:
- Look for @export or var declarations of TileMapLayer
- Look for where furniture visuals are added (probably in furniture placement handling)

If RoomBuildController uses different variable names, adjust accordingly.
  </action>
  <verify>
Run `grep -n "get_tilemap_layer\|get_furniture_parent" scripts/room_building/RoomBuildController.gd` shows the new accessor methods.
  </verify>
  <done>RoomBuildController exposes tilemap_layer and furniture_parent via getter methods.</done>
</task>

<task type="auto">
  <name>Task 3: Ensure furniture visual position uses FurnitureOperation properly</name>
  <files>scripts/Main.gd</files>
  <action>
Verify the _on_furniture_added handler correctly creates furniture visuals:

1. Check that FurnitureOperation is available (may need to add at top of Main.gd):
```gdscript
# Preload not needed since FurnitureOperation has class_name
```

2. Update _on_furniture_added if needed (should already be close to correct from Task 3 of Plan 04):
```gdscript
func _on_furniture_added(room: RoomInstance, placement: RoomInstance.FurniturePlacement) -> void:
    # Get tilemap layer from room build manager
    var tilemap_layer = room_build_manager.get_tilemap_layer()
    var furniture_parent = room_build_manager.get_furniture_parent()

    if furniture_parent:
        var furniture_op = FurnitureOperation.new()
        # Note: tilemap_layer can be null - FurnitureOperation handles this
        var visual = furniture_op.create_furniture_visual(placement, furniture_parent, tilemap_layer)
        # visual_node is now set by FurnitureOperation

    print("Furniture added: ", placement.furniture.name if placement.furniture else "unknown")
```

3. Also ensure furniture controller refreshes its Area2D for the new furniture. This should already happen via _recreate_furniture_areas() call in confirm_placement().
  </action>
  <verify>
Run the game, enter furniture edit mode, add new furniture:
1. Tap "Add Furniture" button
2. Select furniture from picker
3. Move cursor - preview should follow with valid/invalid colors
4. Tap valid position - furniture appears in room with correct visual
5. New furniture appears in list panel
6. New furniture is tappable/selectable
  </verify>
  <done>Furniture add flow creates visual nodes correctly and refreshes UI state.</done>
</task>

</tasks>

<verification>
1. FurnitureSelectionHighlight connects to placement_mode_entered/exited/preview_updated signals
2. FurnitureSelectionHighlight._draw_placement_preview renders at cursor position
3. RoomBuildController.get_tilemap_layer() returns the TileMapLayer
4. RoomBuildController.get_furniture_parent() returns valid parent node
5. Main._on_furniture_added creates visual via FurnitureOperation
</verification>

<success_criteria>
1. Placement mode shows ghost preview following cursor
2. Green preview for valid positions, red for invalid
3. Furniture visual appears at correct position after placement confirmed
4. New furniture is selectable in room view
5. New furniture appears in list panel
</success_criteria>

<output>
After completion, create `.planning/phases/05-furniture-editing-operations/05-05-SUMMARY.md`
</output>
