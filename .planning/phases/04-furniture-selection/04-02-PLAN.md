---
phase: 04-furniture-selection
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - scripts/room_editing/FurnitureListPanel.gd
  - scripts/Main.gd
autonomous: true

must_haves:
  truths:
    - "Furniture list panel shows all furniture in selected room"
    - "Selecting from list highlights corresponding furniture in room"
    - "Tapping furniture in room selects it in list (bi-directional)"
    - "Panel scrolls if room has many furniture items"
    - "Panel hides when exiting furniture edit mode"
  artifacts:
    - path: "scripts/room_editing/FurnitureListPanel.gd"
      provides: "Scrollable list UI for furniture in room"
      exports: ["furniture_item_selected"]
      min_lines: 80
  key_links:
    - from: "scripts/room_editing/FurnitureListPanel.gd"
      to: "scripts/room_editing/FurnitureEditController.gd"
      via: "furniture_item_selected -> select_furniture"
      pattern: "furniture_item_selected"
    - from: "scripts/room_editing/FurnitureEditController.gd"
      to: "scripts/room_editing/FurnitureListPanel.gd"
      via: "furniture_selected signal updates list selection"
      pattern: "furniture_selected\\.connect"
---

<objective>
Implement furniture list panel UI for alternative selection method.

Purpose: Provide list-based furniture selection for accessibility and discoverability, synchronized with tap selection in room view.

Output: FurnitureListPanel showing all furniture in room with bi-directional selection sync.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan context
@.planning/phases/04-furniture-selection/04-01-SUMMARY.md

# Existing patterns
@scripts/room_editing/RoomEditMenu.gd      # PanelContainer + VBoxContainer pattern
@scripts/room_editing/FurnitureEditController.gd  # Controller to sync with
@scripts/storage/RoomInstance.gd           # furniture array
@scripts/data/FurnitureResource.gd         # Furniture name, id
@scripts/utils/UIStyleHelper.gd            # Styled button/panel helpers
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FurnitureListPanel</name>
  <files>scripts/room_editing/FurnitureListPanel.gd</files>
  <action>
Create FurnitureListPanel Control that displays furniture in the current room as a scrollable list:

**Structure:**
```
FurnitureListPanel (Control, PRESET_FULL_RECT, MOUSE_FILTER_IGNORE)
└── PanelContainer (anchored bottom-left, MOUSE_FILTER_STOP)
    └── MarginContainer
        └── VBoxContainer
            ├── Label ("Furniture")
            ├── ScrollContainer
            │   └── VBoxContainer (_items_container)
            │       └── [FurnitureItemButton...] (created dynamically)
            └── Button ("Done")
```

**Signals:**
- `furniture_item_selected(index: int, furniture: RoomInstance.FurniturePlacement)`
- `done_pressed`

**State:**
- `_controller: FurnitureEditController`
- `_panel: PanelContainer`
- `_items_container: VBoxContainer`
- `_item_buttons: Array[Button]`
- `_selected_index: int = -1`

**Public Methods:**
- `set_controller(controller: FurnitureEditController)` - Wire signals
- `show_for_room(room: RoomInstance)` - Populate list and show
- `hide_panel()` - Hide and clear list
- `select_item(index: int)` - Highlight item in list (called when furniture tapped in room)

**Private Methods:**
- `_create_panel()` - Build panel structure in _ready
- `_populate_list(room: RoomInstance)` - Create buttons for each furniture
- `_clear_list()` - Remove all item buttons
- `_on_item_pressed(index: int, furniture: RoomInstance.FurniturePlacement)` - Emit signal
- `_on_done_pressed()` - Emit done_pressed

**Panel Layout:**
- Anchor: PRESET_BOTTOM_LEFT with margin (20px from edges)
- Width: 200px fixed
- Height: min 150px, max 300px (scrolls if more items)
- ScrollContainer: max height 200px

**Item Button Style:**
```gdscript
func _create_item_button(index: int, furniture: RoomInstance.FurniturePlacement) -> Button:
    var furn_resource = furniture.furniture
    var btn = UIStyleHelper.create_styled_button(
        furn_resource.name if furn_resource else "Unknown",
        Vector2(180, 36)
    )
    btn.pressed.connect(_on_item_pressed.bind(index, furniture))
    return btn
```

**Selection Highlighting:**
When item selected (via tap in room or list click):
```gdscript
func select_item(index: int) -> void:
    # Unhighlight previous
    if _selected_index >= 0 and _selected_index < _item_buttons.size():
        UIStyleHelper.apply_button_style(_item_buttons[_selected_index])

    _selected_index = index

    # Highlight new selection with accent color
    if index >= 0 and index < _item_buttons.size():
        UIStyleHelper.apply_button_style(
            _item_buttons[index],
            Color(0.2, 0.5, 0.6, 1.0)  # Cyan-ish to match furniture highlight
        )
```

**Signal Connections (in set_controller):**
```gdscript
func set_controller(controller: FurnitureEditController) -> void:
    _controller = controller
    _controller.furniture_selected.connect(_on_controller_furniture_selected)
    _controller.furniture_deselected.connect(_on_controller_furniture_deselected)
    _controller.mode_exited.connect(_on_controller_mode_exited)

func _on_controller_furniture_selected(room: RoomInstance, furniture: RoomInstance.FurniturePlacement) -> void:
    # Find index of this furniture in room.furniture array
    var index = room.furniture.find(furniture)
    if index >= 0:
        select_item(index)

func _on_controller_furniture_deselected() -> void:
    select_item(-1)  # Clear selection

func _on_controller_mode_exited() -> void:
    hide_panel()
```
  </action>
  <verify>
1. File exists at scripts/room_editing/FurnitureListPanel.gd
2. Script has class_name FurnitureListPanel
3. Has all required signals and methods
4. Godot editor loads without errors
  </verify>
  <done>
FurnitureListPanel displays furniture list, supports selection, scrolls if needed, syncs with FurnitureEditController.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate FurnitureListPanel and Complete Bi-directional Sync</name>
  <files>scripts/Main.gd, scripts/room_editing/FurnitureEditController.gd</files>
  <action>
**Update Main.gd:**

1. Add FurnitureListPanel instance variable:
```gdscript
var _furniture_list_panel: FurnitureListPanel
```

2. In _ready(), after furniture_highlight setup:
```gdscript
# Create furniture list panel (in EditMenuLayer since it's UI)
_furniture_list_panel = FurnitureListPanel.new()
_furniture_list_panel.name = "FurnitureListPanel"
edit_menu_layer.add_child(_furniture_list_panel)  # Use existing EditMenuLayer (layer 1)
_furniture_list_panel.set_controller(_furniture_controller)
```

3. Update _on_edit_furniture_requested:
```gdscript
func _on_edit_furniture_requested(room: RoomInstance) -> void:
    print("Entering furniture edit mode: ", room.id)
    RoomManager.clear_selection()
    _furniture_controller.enter_edit_mode(room)
    _furniture_list_panel.show_for_room(room)  # Show list panel
```

4. Connect list panel signals:
```gdscript
# In _ready after panel creation:
_furniture_list_panel.furniture_item_selected.connect(_on_furniture_list_item_selected)
_furniture_list_panel.done_pressed.connect(_on_furniture_edit_done)

func _on_furniture_list_item_selected(index: int, furniture: RoomInstance.FurniturePlacement) -> void:
    _furniture_controller.select_furniture(furniture)  # Need to add this method

func _on_furniture_edit_done() -> void:
    _furniture_controller.exit_edit_mode()
```

**Update FurnitureEditController.gd:**

Add select_furniture public method for list panel to call:
```gdscript
func select_furniture(furniture: RoomInstance.FurniturePlacement) -> void:
    if not _active or _current_room == null:
        return

    # Verify furniture belongs to current room
    if furniture not in _current_room.furniture:
        return

    _selected_furniture = furniture
    furniture_selected.emit(_current_room, furniture)
```

This creates bi-directional sync:
- Tap furniture in room -> FurnitureEditController.furniture_selected -> FurnitureListPanel.select_item
- Click item in list -> FurnitureListPanel.furniture_item_selected -> Main._on_furniture_list_item_selected -> FurnitureEditController.select_furniture -> furniture_selected -> FurnitureSelectionHighlight redraws
  </action>
  <verify>
1. Run game: `godot --path .`
2. Build room with multiple furniture pieces
3. Select room -> Edit Furniture
4. Verify list panel appears in bottom-left
5. Click furniture in list -> cyan highlight appears on that furniture
6. Tap different furniture in room -> list selection updates to match
7. Click "Done" -> furniture edit mode exits, list panel hides
  </verify>
  <done>
Bi-directional sync complete: list selection and room tap selection stay synchronized, Done button exits furniture edit mode.
  </done>
</task>

</tasks>

<verification>
1. **List Display:** Entering furniture edit mode shows list panel with all room furniture
2. **List -> Room:** Clicking furniture name in list highlights that furniture in room (cyan)
3. **Room -> List:** Tapping furniture in room highlights that item in list
4. **Scroll:** If room has 5+ furniture items, list scrolls
5. **Done Button:** Clicking Done exits furniture edit mode, hides list and highlight
6. **Clean Exit:** After Done, can select room again normally
</verification>

<success_criteria>
- Furniture list panel displays all furniture in selected room
- Selecting from list highlights corresponding furniture in room
- Tapping furniture in room selects it in list (bi-directional sync)
- Panel scrolls if room has many furniture items
- Done button exits furniture edit mode cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/04-furniture-selection/04-02-SUMMARY.md`
</output>
