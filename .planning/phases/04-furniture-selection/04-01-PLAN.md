---
phase: 04-furniture-selection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Scripts/room_editing/FurnitureEditController.gd
  - Scripts/room_editing/FurnitureSelectionHighlight.gd
  - Scripts/Main.gd
autonomous: true

must_haves:
  truths:
    - "Tapping Edit Furniture button enters furniture edit mode"
    - "Tapping furniture in room selects that furniture piece"
    - "Selected furniture shows cyan highlight (distinct from room yellow)"
    - "Tapping outside furniture deselects current selection"
    - "Exit furniture edit mode returns to room selection"
  artifacts:
    - path: "Scripts/room_editing/FurnitureEditController.gd"
      provides: "Furniture edit mode state machine and selection logic"
      exports: ["furniture_selected", "furniture_deselected", "mode_exited"]
    - path: "Scripts/room_editing/FurnitureSelectionHighlight.gd"
      provides: "Visual highlight for selected furniture"
      min_lines: 30
  key_links:
    - from: "Scripts/Main.gd"
      to: "Scripts/room_editing/FurnitureEditController.gd"
      via: "edit_furniture_pressed signal connection"
      pattern: "edit_furniture_pressed\\.connect"
    - from: "Scripts/room_editing/FurnitureEditController.gd"
      to: "Scripts/room_editing/FurnitureSelectionHighlight.gd"
      via: "furniture_selected signal"
      pattern: "furniture_selected\\.connect"
---

<objective>
Implement furniture tap selection with visual highlight in furniture edit mode.

Purpose: Enable players to select individual furniture pieces by tapping directly on them, with clear visual feedback distinguishing furniture selection from room selection.

Output: FurnitureEditController managing edit mode state, tap detection on furniture footprints, cyan highlight on selected furniture.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns to follow
@Scripts/RoomManager.gd                    # Area2D tap detection pattern
@Scripts/room_building/RoomSelectionHighlight.gd  # Highlight drawing pattern
@Scripts/room_editing/RoomEditMenu.gd      # Entry signal: edit_furniture_pressed
@Scripts/storage/RoomInstance.gd           # furniture array, FurniturePlacement class
@Scripts/utils/IsometricMath.gd            # Coordinate conversion
@scripts/room_building/ui/RoomBuildDrawing.gd  # draw_tile_highlight helper
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FurnitureEditController</name>
  <files>Scripts/room_editing/FurnitureEditController.gd</files>
  <action>
Create FurnitureEditController as a Control node (not autoload - instantiated by Main.gd) that manages furniture editing mode:

**Signals:**
- `furniture_selected(room: RoomInstance, furniture: RoomInstance.FurniturePlacement)`
- `furniture_deselected`
- `mode_exited`

**State:**
- `_active: bool` - Is furniture edit mode active
- `_current_room: RoomInstance` - The room being edited
- `_selected_furniture: RoomInstance.FurniturePlacement` - Currently selected piece
- `_furniture_areas: Dictionary` - Maps furniture index to Area2D

**Public Methods:**
- `enter_edit_mode(room: RoomInstance)` - Start editing furniture in room
- `exit_edit_mode()` - Return to room selection
- `get_selected_furniture() -> RoomInstance.FurniturePlacement`
- `get_current_room() -> RoomInstance`

**Private Methods:**
- `_create_furniture_areas(room: RoomInstance)` - Create Area2D for each furniture piece
- `_clear_furniture_areas()` - Remove all Area2D nodes
- `_furniture_to_polygon(furn: RoomInstance.FurniturePlacement) -> PackedVector2Array` - Convert footprint to isometric diamond polygon

**Area2D Creation (follow RoomManager pattern):**
1. For each furniture in room.furniture:
2. Create Area2D with input_pickable = true
3. Create CollisionPolygon2D with polygon from `_furniture_to_polygon`
4. Connect area.input_event to `_on_furniture_input.bind(index, furniture)`
5. Store in _furniture_areas dictionary

**Tap Detection (follow RoomManager pattern):**
- Use same 20px/300ms thresholds as RoomManager
- Handle both InputEventMouseButton and InputEventScreenTouch
- On valid tap: set _selected_furniture, emit furniture_selected

**Minimum Tap Area:**
For small 1x1 furniture, ensure minimum 44x44 pixel tap target:
```gdscript
# In _furniture_to_polygon, after calculating base polygon:
# Check if polygon bounding box is < 44x44 pixels
# If so, expand polygon uniformly from center
```

**_unhandled_input for deselection:**
- If active and click/tap outside any furniture area, emit furniture_deselected

**Exit Mode:**
- Clear selection, clear areas, set _active = false, emit mode_exited
  </action>
  <verify>
1. File exists at Scripts/room_editing/FurnitureEditController.gd
2. Script has class_name FurnitureEditController
3. Has all required signals and methods
4. Godot editor loads without errors: `godot --headless --check-only --path .`
  </verify>
  <done>
FurnitureEditController can enter/exit furniture edit mode, create tap detection areas for furniture, and emit selection signals.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FurnitureSelectionHighlight</name>
  <files>Scripts/room_editing/FurnitureSelectionHighlight.gd</files>
  <action>
Create FurnitureSelectionHighlight Control (following RoomSelectionHighlight pattern) that draws highlight on selected furniture:

**Constants:**
```gdscript
const SELECTION_COLOR := Color(0.2, 0.8, 1.0, 0.4)  # Semi-transparent cyan (distinct from room yellow)
const ACCESS_TILE_COLOR := Color(0.2, 0.8, 1.0, 0.2)  # Lighter cyan for access tiles
```

**Dependencies:**
- Does NOT connect to RoomManager (furniture selection is separate)
- Will receive FurnitureEditController reference via initialization

**State:**
- `_controller: FurnitureEditController` - Reference to controller

**_ready:**
```gdscript
func _ready() -> void:
    # Controller reference set by Main.gd after instantiation
    pass

func set_controller(controller: FurnitureEditController) -> void:
    _controller = controller
    _controller.furniture_selected.connect(_on_furniture_selected)
    _controller.furniture_deselected.connect(_on_furniture_deselected)
    _controller.mode_exited.connect(_on_mode_exited)
```

**Signal Handlers:**
- `_on_furniture_selected(_room, _furniture)` -> queue_redraw()
- `_on_furniture_deselected()` -> queue_redraw()
- `_on_mode_exited()` -> queue_redraw()

**_draw:**
1. Get selected furniture from controller
2. If none selected, return early
3. Draw occupied tiles with SELECTION_COLOR using RoomBuildDrawing.draw_tile_highlight
4. Draw access tiles with ACCESS_TILE_COLOR (lighter, shows where patrons stand)
  </action>
  <verify>
1. File exists at Scripts/room_editing/FurnitureSelectionHighlight.gd
2. Script has class_name FurnitureSelectionHighlight
3. Uses distinct cyan color (not yellow like room selection)
4. Godot editor loads without errors
  </verify>
  <done>
FurnitureSelectionHighlight draws cyan highlight over selected furniture footprint and access tiles.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate into Main.gd</name>
  <files>Scripts/Main.gd</files>
  <action>
Update Main.gd to wire FurnitureEditController and FurnitureSelectionHighlight:

**In _ready(), after EditMenuLayer setup:**

1. Create a new CanvasLayer for furniture editing UI:
```gdscript
# Create furniture editing CanvasLayer (same layer as room selection for correct z-order)
var furniture_edit_layer = CanvasLayer.new()
furniture_edit_layer.name = "FurnitureEditLayer"
furniture_edit_layer.layer = 0  # Same layer as SelectionHighlightLayer
add_child(furniture_edit_layer)
```

2. Instantiate FurnitureEditController:
```gdscript
var _furniture_controller: FurnitureEditController

# In _ready:
_furniture_controller = FurnitureEditController.new()
_furniture_controller.name = "FurnitureEditController"
_furniture_controller.mouse_filter = Control.MOUSE_FILTER_IGNORE
_furniture_controller.set_anchors_preset(Control.PRESET_FULL_RECT)
furniture_edit_layer.add_child(_furniture_controller)
```

3. Instantiate FurnitureSelectionHighlight:
```gdscript
var furniture_highlight = FurnitureSelectionHighlight.new()
furniture_highlight.name = "FurnitureSelectionHighlight"
furniture_highlight.mouse_filter = Control.MOUSE_FILTER_IGNORE
furniture_highlight.set_anchors_preset(Control.PRESET_FULL_RECT)
furniture_edit_layer.add_child(furniture_highlight)
furniture_highlight.set_controller(_furniture_controller)
```

4. Update _on_edit_furniture_requested:
```gdscript
func _on_edit_furniture_requested(room: RoomInstance) -> void:
    print("Entering furniture edit mode: ", room.id)
    # Hide room edit menu while in furniture edit mode
    # (RoomEditMenu hides itself when selection_cleared fires)
    RoomManager.clear_selection()
    _furniture_controller.enter_edit_mode(room)
```

5. Connect mode_exited to restore room selection state:
```gdscript
# In _ready after controller creation:
_furniture_controller.mode_exited.connect(_on_furniture_edit_exited)

func _on_furniture_edit_exited() -> void:
    print("Exited furniture edit mode")
    # Room can be re-selected now via normal RoomManager flow
```

**Important:** Store _furniture_controller as instance variable (not local) so it persists.
  </action>
  <verify>
1. Run game: `godot --path .`
2. Build a room with furniture (if test room exists)
3. Select room -> Edit Furniture button
4. Verify furniture edit mode enters (console log)
5. Tap furniture -> verify cyan highlight appears
6. Tap outside -> verify highlight clears
  </verify>
  <done>
Main.gd creates FurnitureEditController and FurnitureSelectionHighlight, wires edit_furniture_pressed signal to enter furniture edit mode.
  </done>
</task>

</tasks>

<verification>
1. **Mode Entry:** Click "Edit Furniture" on room menu -> enters furniture edit mode, room menu hides
2. **Tap Selection:** Tap on furniture piece -> cyan highlight appears on that furniture
3. **Visual Distinction:** Furniture highlight is cyan, room highlight is yellow (clearly different)
4. **Deselection:** Tap empty space -> furniture deselects, highlight clears
5. **Minimum Tap Target:** Small 1x1 furniture still selectable (44x44 min touch area)
6. **No Errors:** Console shows no GDScript errors during operation
</verification>

<success_criteria>
- FurnitureEditController enters/exits furniture edit mode correctly
- Tapping furniture in room selects it and shows cyan highlight
- Tapping outside furniture deselects (highlight clears)
- All furniture pieces are selectable regardless of size (minimum tap target enforced)
- Distinct visual feedback from room selection (cyan vs yellow)
</success_criteria>

<output>
After completion, create `.planning/phases/04-furniture-selection/04-01-SUMMARY.md`
</output>
