---
phase: 03-persistence-infrastructure
plan: 04
type: execute
wave: 3
depends_on: ["03-03"]
files_modified:
  - Scripts/RoomManager.gd
  - Scripts/room_building/RoomBuildController.gd
autonomous: false

must_haves:
  truths:
    - "Loaded rooms have visual representation in tilemap"
    - "Loaded rooms have working Area2D selection"
    - "Selection and menu work for restored rooms"
  artifacts:
    - path: "Scripts/RoomManager.gd"
      provides: "Room visual restoration signal"
      contains: "room_restored"
  key_links:
    - from: "RoomManager.room_restored"
      to: "RoomBuildController._on_room_restored()"
      via: "signal connection"
      pattern: "room_restored\\.connect"
---

<objective>
Integrate visual restoration for loaded rooms and verify full persistence flow.

Purpose: Loaded rooms need their visual representation (walls, doors in tilemap) restored. Currently RoomBuildController creates these during the build workflow, but loaded rooms skip that workflow. This plan adds visual restoration and includes human verification of the complete persistence flow.

Output: Rooms loaded from save file display correctly in the tilemap and can be selected/edited.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Files to reference/modify
@Scripts/RoomManager.gd
@Scripts/room_building/RoomBuildController.gd
@Scripts/room_building/operations/WallOperation.gd
@Scripts/room_building/operations/DoorOperation.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add room_restored signal to RoomManager</name>
  <files>Scripts/RoomManager.gd</files>
  <action>
Add a new signal for restored rooms and emit it during load:

1. Add signal at top with other signals:
```gdscript
signal room_restored(room: RoomInstance)
```

2. Update _load_saved_rooms() to emit signal for each restored room:
```gdscript
func _load_saved_rooms() -> void:
    var saved_rooms := RoomSerializer.load_rooms()
    for room in saved_rooms:
        if room == null:
            continue

        var already_exists := false
        for existing in _rooms:
            if existing.id == room.id:
                already_exists = true
                break

        if not already_exists:
            _rooms.append(room)
            _create_selection_area(room)
            room.placement_changed.connect(_on_room_changed)
            # Emit signal for visual restoration
            room_restored.emit(room)

    if saved_rooms.size() > 0:
        print("RoomManager: Restored %d rooms from save file" % saved_rooms.size())
```

This allows other systems (RoomBuildController) to restore visuals for loaded rooms.
  </action>
  <verify>
Read Scripts/RoomManager.gd and confirm room_restored signal exists and is emitted in _load_saved_rooms().
  </verify>
  <done>
room_restored signal emitted for each room loaded from save file.
  </done>
</task>

<task type="auto">
  <name>Task 2: Connect RoomBuildController to restore visuals</name>
  <files>Scripts/room_building/RoomBuildController.gd</files>
  <action>
First, read the current RoomBuildController.gd to understand its structure.

Then add visual restoration for loaded rooms:

1. In _ready() or wherever signals are connected, add:
```gdscript
RoomManager.room_restored.connect(_on_room_restored)
```

2. Add the restoration handler:
```gdscript
func _on_room_restored(room: RoomInstance) -> void:
    # Restore wall visuals
    for wall_pos in room.walls:
        # Use WallOperation or direct tilemap access
        # This depends on how walls are currently rendered
        _wall_tilemap.set_cell(wall_pos, 0, Vector2i(0, 0))  # Adjust atlas coords as needed

    # Restore door visuals
    for door in room.doors:
        # Clear wall at door position, add door visual
        _wall_tilemap.erase_cell(door.position)
        # Door visual depends on your tilemap setup

    # Restore furniture visuals
    for furn in room.furniture:
        if furn.furniture and furn.furniture.scene:
            var instance = furn.furniture.scene.instantiate()
            instance.position = IsometricMath.tile_to_world(furn.position)
            # Add to appropriate parent node
            add_child(instance)

    print("RoomBuildController: Restored visuals for room %s" % room.id)
```

IMPORTANT: This implementation depends heavily on how your current RoomBuildController creates visuals. You need to:
1. Look at how _complete_room() creates wall/door/furniture visuals
2. Extract that logic into a reusable method
3. Call it from _on_room_restored()

The exact implementation will vary based on your tilemap layer structure and furniture instantiation pattern.
  </action>
  <verify>
Read Scripts/room_building/RoomBuildController.gd and confirm:
- RoomManager.room_restored.connect() is called
- _on_room_restored() method exists
- Method restores walls, doors, and furniture visuals
  </verify>
  <done>
RoomBuildController restores visual representation for rooms loaded from save file.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete persistence infrastructure:
1. RoomInstance serialization (to_dict/from_dict)
2. RoomSerializer atomic JSON file I/O
3. RoomManager auto-save with 5s debounce
4. Load-on-startup with visual restoration
5. App suspension immediate save
  </what-built>
  <how-to-verify>
Test the complete persistence flow:

1. **Initial save test:**
   - Run the game
   - Build a room (draw box, place door)
   - Wait 6+ seconds for auto-save
   - Check that `user://saves/rooms.json` exists
   - On Windows: `%APPDATA%\Godot\app_userdata\TheaterCity\saves\rooms.json`
   - Verify JSON contains room data (id, bounding_box, walls, doors)

2. **Load test:**
   - Close the game completely
   - Run the game again
   - Verify the room appears in the tilemap (walls visible)
   - Click/tap the room - should highlight and show edit menu
   - If room exists but no visuals, Task 2 needs adjustment

3. **Furniture persistence test (if furniture placement exists):**
   - Build a room with furniture
   - Wait for auto-save
   - Quit and restart
   - Verify furniture appears in correct positions

4. **Corruption resilience test:**
   - Manually corrupt the save file (add garbage text)
   - Run the game
   - Should start with empty rooms (graceful degradation)
   - No crash should occur

5. **Mobile suspension test (if testing on Android):**
   - Build a room
   - Immediately switch to another app (before 5s debounce)
   - Come back to game
   - Force quit and restart
   - Room should persist (suspension triggered save)
  </how-to-verify>
  <resume-signal>
Type "approved" if all tests pass, or describe which tests failed and what you observed.
  </resume-signal>
</task>

</tasks>

<verification>
After human verification:

1. Rooms persist across game sessions
2. All room data restored: position, walls, doors, furniture
3. Restored rooms are selectable (Area2D works)
4. Restored rooms show edit menu
5. Corrupted save file doesn't crash game
6. App suspension saves data
</verification>

<success_criteria>
- Build room -> quit -> restart -> room exists with correct visuals
- Room selection and edit menu work for restored rooms
- Furniture positions persist correctly
- Corrupted save file = graceful fallback to empty state
- No data loss on mobile app backgrounding
</success_criteria>

<output>
After completion, create `.planning/phases/03-persistence-infrastructure/03-04-SUMMARY.md`
</output>
