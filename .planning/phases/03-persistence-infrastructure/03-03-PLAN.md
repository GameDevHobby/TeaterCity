---
phase: 03-persistence-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - Scripts/RoomManager.gd
autonomous: true

must_haves:
  truths:
    - "Rooms auto-save when changes occur"
    - "Rooms load from save file on game start"
    - "Save is debounced (5 second delay)"
    - "Save triggers on app suspension (mobile)"
  artifacts:
    - path: "Scripts/RoomManager.gd"
      provides: "Auto-save integration and load on startup"
      contains: "_save_debounce_timer"
  key_links:
    - from: "RoomManager._ready()"
      to: "RoomSerializer.load_rooms()"
      via: "startup load"
      pattern: "RoomSerializer\\.load_rooms"
    - from: "RoomManager.register_room()"
      to: "_schedule_save()"
      via: "change trigger"
      pattern: "_schedule_save"
    - from: "_on_save_timer_timeout()"
      to: "RoomSerializer.save_rooms()"
      via: "debounced save"
      pattern: "RoomSerializer\\.save_rooms"
---

<objective>
Integrate auto-save and load-on-startup into RoomManager.

Purpose: Connect the persistence layer to the room tracking system. Rooms automatically save when added/modified (debounced 5s), and load from disk when the game starts. Mobile app suspension triggers immediate save.

Output: RoomManager.gd updated with auto-save, debounce timer, and load-on-startup logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Files to modify
@Scripts/RoomManager.gd

# Depends on serialization layer
@Scripts/storage/RoomInstance.gd
@Scripts/storage/RoomSerializer.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add load-on-startup to RoomManager</name>
  <files>Scripts/RoomManager.gd</files>
  <action>
Add _ready() function to RoomManager that loads saved rooms on startup:

```gdscript
func _ready() -> void:
    _load_saved_rooms()


func _load_saved_rooms() -> void:
    var saved_rooms := RoomSerializer.load_rooms()
    for room in saved_rooms:
        # Register without triggering save (we just loaded!)
        if room == null:
            continue

        # Check if room already registered (shouldn't happen, but safe)
        var already_exists := false
        for existing in _rooms:
            if existing.id == room.id:
                already_exists = true
                break

        if not already_exists:
            _rooms.append(room)
            _create_selection_area(room)
            # Don't emit room_added here - these are restored, not newly added
            # Connect to placement_changed for future changes
            room.placement_changed.connect(_on_room_changed)

    if saved_rooms.size() > 0:
        print("RoomManager: Restored %d rooms from save file" % saved_rooms.size())
```

IMPORTANT: Do NOT call register_room() for loaded rooms - that would trigger save. Add directly to _rooms array.

IMPORTANT: Do NOT emit room_added signal for restored rooms - they're not "new", they're restored state.

IMPORTANT: Connect to placement_changed signal on loaded rooms so future furniture/door changes trigger save.
  </action>
  <verify>
Read Scripts/RoomManager.gd and confirm _ready() calls _load_saved_rooms() which uses RoomSerializer.load_rooms().
  </verify>
  <done>
RoomManager loads saved rooms on game startup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add debounced auto-save</name>
  <files>Scripts/RoomManager.gd</files>
  <action>
Add auto-save with 5-second debounce timer:

1. Add constants and variables at top:
```gdscript
# Auto-save configuration
const SAVE_DEBOUNCE_SECONDS := 5.0

# Auto-save state
var _save_debounce_timer: Timer = null
var _save_pending := false
```

2. Add timer setup in _ready() (after _load_saved_rooms):
```gdscript
func _ready() -> void:
    _load_saved_rooms()
    _setup_save_timer()


func _setup_save_timer() -> void:
    _save_debounce_timer = Timer.new()
    _save_debounce_timer.one_shot = true
    _save_debounce_timer.wait_time = SAVE_DEBOUNCE_SECONDS
    _save_debounce_timer.timeout.connect(_on_save_timer_timeout)
    add_child(_save_debounce_timer)
```

3. Add save scheduling and execution:
```gdscript
func _schedule_save() -> void:
    _save_pending = true
    # Reset timer if already running (debounce)
    if _save_debounce_timer.is_stopped():
        _save_debounce_timer.start()
    else:
        # Timer already running, it will save when it fires
        pass


func _on_save_timer_timeout() -> void:
    if _save_pending:
        _save_pending = false
        _perform_save()


func _perform_save() -> void:
    var success := RoomSerializer.save_rooms(_rooms)
    if success:
        print("RoomManager: Auto-saved %d rooms" % _rooms.size())
    else:
        push_error("RoomManager: Auto-save failed!")
```

4. Add callback for room changes:
```gdscript
func _on_room_changed() -> void:
    _schedule_save()
```

5. Update register_room() to connect signal and schedule save:
```gdscript
func register_room(room: RoomInstance) -> void:
    if room == null:
        return

    # Check if room already registered
    for existing_room in _rooms:
        if existing_room.id == room.id:
            return

    _rooms.append(room)
    _create_selection_area(room)

    # Connect to placement_changed for auto-save
    room.placement_changed.connect(_on_room_changed)

    room_added.emit(room)

    # Schedule save for new room
    _schedule_save()
```

IMPORTANT: Use one_shot = true on timer so it doesn't repeat.

IMPORTANT: Connect placement_changed signal to _on_room_changed for furniture/door auto-save (PER-02).

IMPORTANT: Debounce logic: if timer already running, let it fire (don't restart). This prevents excessive saves during rapid changes.
  </action>
  <verify>
Read Scripts/RoomManager.gd and confirm:
- Timer created in _ready()
- _schedule_save() starts debounce timer
- _on_save_timer_timeout() calls _perform_save()
- register_room() calls _schedule_save()
- placement_changed signal connected for furniture changes
  </verify>
  <done>
Auto-save triggers on room registration and placement changes with 5-second debounce.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add app suspension save (mobile)</name>
  <files>Scripts/RoomManager.gd</files>
  <action>
Add NOTIFICATION_WM_GO_BACKGROUND handler for immediate save on mobile app suspension:

```gdscript
func _notification(what: int) -> void:
    match what:
        NOTIFICATION_WM_GO_BACKGROUND:
            # App going to background (mobile) - save immediately
            if _save_pending:
                _save_debounce_timer.stop()
                _perform_save()
        NOTIFICATION_WM_CLOSE_REQUEST:
            # Window close requested (desktop) - save immediately
            if _save_pending:
                _save_debounce_timer.stop()
                _perform_save()
```

This ensures data is saved when:
- Mobile app goes to background (user switches apps)
- Desktop window is closed

The debounce timer is stopped and save performed immediately to prevent data loss.
  </action>
  <verify>
Read Scripts/RoomManager.gd and confirm _notification() handles NOTIFICATION_WM_GO_BACKGROUND and NOTIFICATION_WM_CLOSE_REQUEST.
  </verify>
  <done>
App suspension and window close trigger immediate save (no data loss on mobile).
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. RoomManager loads saved rooms in _ready() via _load_saved_rooms()
2. register_room() schedules debounced save
3. placement_changed signal triggers save (furniture/door changes)
4. 5-second debounce timer prevents excessive saves
5. App suspension (NOTIFICATION_WM_GO_BACKGROUND) triggers immediate save
6. Window close triggers immediate save

Manual test:
1. Run game, build a room, quit
2. Run game again - room should still exist
3. Verify user://saves/rooms.json exists and contains room data
</verification>

<success_criteria>
- Game loads previously saved rooms on startup
- New rooms auto-save after 5-second debounce
- Furniture/door changes trigger auto-save (infrastructure ready - full verification requires Phase 5 furniture editing)
- App suspension saves immediately
- No data loss on mobile app backgrounding

Note: PER-02 (furniture auto-save) infrastructure is wired via placement_changed signal, but furniture editing operations are implemented in Phase 5. Full PER-02 verification deferred to Phase 5 integration testing.
</success_criteria>

<output>
After completion, create `.planning/phases/03-persistence-infrastructure/03-03-SUMMARY.md`
</output>
