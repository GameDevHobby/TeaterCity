---
phase: 03-persistence-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - scripts/storage/RoomSerializer.gd
autonomous: true

must_haves:
  truths:
    - "Rooms can be saved to a JSON file"
    - "Rooms can be loaded from a JSON file"
    - "Corrupted save file does not crash the game"
    - "Save file uses atomic write pattern (temp + rename)"
  artifacts:
    - path: "scripts/storage/RoomSerializer.gd"
      provides: "File I/O for room persistence"
      exports: ["save_rooms", "load_rooms"]
      min_lines: 60
  key_links:
    - from: "RoomSerializer.save_rooms()"
      to: "RoomInstance.to_dict()"
      via: "serialization call"
      pattern: "room\\.to_dict\\(\\)"
    - from: "RoomSerializer.load_rooms()"
      to: "RoomInstance.from_dict()"
      via: "deserialization call"
      pattern: "RoomInstance\\.from_dict"
---

<objective>
Create RoomSerializer class for atomic file I/O operations.

Purpose: Handle all file system interactions for room persistence. Uses atomic write pattern (write to temp file, verify, rename) to prevent data corruption on mobile where app can be killed mid-write.

Output: RoomSerializer.gd with save_rooms() and load_rooms() methods that use JSON format and atomic writes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Depends on serialization from Plan 01
@scripts/storage/RoomInstance.gd

# Registry patterns
@scripts/data/FurnitureRegistry.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RoomSerializer with save/load methods</name>
  <files>scripts/storage/RoomSerializer.gd</files>
  <action>
Create new file scripts/storage/RoomSerializer.gd as a RefCounted class (stateless helper, not a singleton):

```gdscript
class_name RoomSerializer
extends RefCounted

## RoomSerializer handles atomic file I/O for room persistence.
## Uses JSON format as specified in PROJECT.md.

const SAVE_PATH := "user://saves/rooms.json"
const TEMP_PATH := "user://saves/rooms.json.tmp"
const SAVE_DIR := "user://saves"

## Save rooms to JSON file using atomic write pattern.
## Returns true on success, false on failure.
static func save_rooms(rooms: Array[RoomInstance]) -> bool:
    # Ensure save directory exists
    if not DirAccess.dir_exists_absolute(SAVE_DIR):
        var err = DirAccess.make_dir_recursive_absolute(SAVE_DIR)
        if err != OK:
            push_error("RoomSerializer: Failed to create save directory: %s" % error_string(err))
            return false

    # Build save data
    var rooms_data: Array = []
    for room in rooms:
        rooms_data.append(room.to_dict())

    var save_data := {
        "version": 1,
        "saved_at": Time.get_datetime_string_from_system(),
        "rooms": rooms_data
    }

    # Convert to JSON
    var json_string := JSON.stringify(save_data, "  ")

    # Write to temp file first (atomic write pattern)
    var file := FileAccess.open(TEMP_PATH, FileAccess.WRITE)
    if file == null:
        push_error("RoomSerializer: Failed to open temp file: %s" % error_string(FileAccess.get_open_error()))
        return false

    file.store_string(json_string)
    file.close()

    # Verify temp file is valid JSON before renaming
    if not _verify_json_file(TEMP_PATH):
        push_error("RoomSerializer: Temp file verification failed")
        DirAccess.remove_absolute(TEMP_PATH)
        return false

    # Atomic rename: delete old file, rename temp to final
    if FileAccess.file_exists(SAVE_PATH):
        var err = DirAccess.remove_absolute(SAVE_PATH)
        if err != OK:
            push_error("RoomSerializer: Failed to remove old save: %s" % error_string(err))
            return false

    var err = DirAccess.rename_absolute(TEMP_PATH, SAVE_PATH)
    if err != OK:
        push_error("RoomSerializer: Failed to rename temp to save: %s" % error_string(err))
        return false

    print("RoomSerializer: Saved %d rooms to %s" % [rooms.size(), SAVE_PATH])
    return true


## Load rooms from JSON file.
## Returns empty array on failure (graceful degradation).
static func load_rooms() -> Array[RoomInstance]:
    var rooms: Array[RoomInstance] = []

    if not FileAccess.file_exists(SAVE_PATH):
        print("RoomSerializer: No save file found at %s" % SAVE_PATH)
        return rooms

    var file := FileAccess.open(SAVE_PATH, FileAccess.READ)
    if file == null:
        push_error("RoomSerializer: Failed to open save file: %s" % error_string(FileAccess.get_open_error()))
        return rooms

    var json_string := file.get_as_text()
    file.close()

    # Parse JSON
    var json := JSON.new()
    var parse_result := json.parse(json_string)
    if parse_result != OK:
        push_error("RoomSerializer: JSON parse error at line %d: %s" % [json.get_error_line(), json.get_error_message()])
        return rooms

    var data = json.data
    if not data is Dictionary:
        push_error("RoomSerializer: Save file root is not a Dictionary")
        return rooms

    # Validate structure
    if not data.has("rooms") or not data.rooms is Array:
        push_error("RoomSerializer: Save file missing 'rooms' array")
        return rooms

    # Deserialize rooms
    for room_data in data.rooms:
        if room_data is Dictionary:
            var room := RoomInstance.from_dict(room_data)
            if room != null:
                rooms.append(room)
            else:
                push_warning("RoomSerializer: Skipping invalid room data")
        else:
            push_warning("RoomSerializer: Skipping non-Dictionary room entry")

    print("RoomSerializer: Loaded %d rooms from %s" % [rooms.size(), SAVE_PATH])
    return rooms


## Verify a JSON file can be parsed correctly.
static func _verify_json_file(path: String) -> bool:
    if not FileAccess.file_exists(path):
        return false

    var file := FileAccess.open(path, FileAccess.READ)
    if file == null:
        return false

    var content := file.get_as_text()
    file.close()

    var json := JSON.new()
    return json.parse(content) == OK


## Check if a save file exists.
static func has_save_file() -> bool:
    return FileAccess.file_exists(SAVE_PATH)


## Delete the save file (for admin reset feature).
static func delete_save_file() -> bool:
    if not FileAccess.file_exists(SAVE_PATH):
        return true

    var err = DirAccess.remove_absolute(SAVE_PATH)
    if err != OK:
        push_error("RoomSerializer: Failed to delete save file: %s" % error_string(err))
        return false

    print("RoomSerializer: Deleted save file")
    return true
```

IMPORTANT: Use "user://saves/rooms.json" path (not .dat) per PROJECT.md specifying JSON format.

IMPORTANT: Atomic write pattern prevents corruption:
1. Write to .tmp file
2. Verify .tmp file is valid JSON
3. Delete old file
4. Rename .tmp to final

IMPORTANT: All errors logged with push_error(), graceful degradation returns empty array on load failure.
  </action>
  <verify>
Read scripts/storage/RoomSerializer.gd and confirm:
- save_rooms() and load_rooms() static methods exist
- Uses atomic write pattern (TEMP_PATH, verify, rename)
- Uses JSON format with proper error handling
- Graceful degradation on corrupted/missing files
  </verify>
  <done>
RoomSerializer provides atomic JSON file I/O for room persistence with corruption protection.
  </done>
</task>

</tasks>

<verification>
After task completes:

1. scripts/storage/RoomSerializer.gd exists with:
   - SAVE_PATH = "user://saves/rooms.json"
   - TEMP_PATH = "user://saves/rooms.json.tmp"
   - save_rooms(Array[RoomInstance]) -> bool
   - load_rooms() -> Array[RoomInstance]
   - has_save_file() -> bool
   - delete_save_file() -> bool

2. Atomic write pattern: temp file -> verify -> rename
3. All errors use push_error() and return gracefully
4. JSON format used (not binary store_var)
</verification>

<success_criteria>
- save_rooms() writes valid JSON to user://saves/rooms.json
- load_rooms() returns Array[RoomInstance] from JSON file
- Corrupted JSON returns empty array (no crash)
- Missing save file returns empty array (no crash)
- Atomic write prevents partial writes on mobile
</success_criteria>

<output>
After completion, create `.planning/phases/03-persistence-infrastructure/03-02-SUMMARY.md`
</output>
