---
phase: 03-persistence-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/storage/RoomInstance.gd
autonomous: true

must_haves:
  truths:
    - "RoomInstance can be converted to a Dictionary"
    - "Dictionary can be converted back to a RoomInstance"
    - "Round-trip preserves all room data (id, type, bbox, walls, doors, furniture)"
  artifacts:
    - path: "scripts/storage/RoomInstance.gd"
      provides: "to_dict() and from_dict() serialization methods"
      contains: "func to_dict"
  key_links:
    - from: "to_dict()"
      to: "from_dict()"
      via: "Dictionary structure"
      pattern: "from_dict.*to_dict"
---

<objective>
Add JSON serialization methods to RoomInstance for save/load support.

Purpose: Enable RoomInstance data to be converted to/from Dictionary format for JSON persistence. This is the foundation for the persistence layer - all save/load operations will use these methods.

Output: RoomInstance.gd with to_dict() and static from_dict() methods that handle all nested data (DoorPlacement, FurniturePlacement).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key files to modify
@scripts/storage/RoomInstance.gd

# Registry pattern for furniture lookup during deserialization
@scripts/data/FurnitureRegistry.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add serialization methods to inner classes</name>
  <files>scripts/storage/RoomInstance.gd</files>
  <action>
Add to_dict() and static from_dict() methods to the inner classes DoorPlacement and FurniturePlacement.

For DoorPlacement:
```gdscript
func to_dict() -> Dictionary:
    return {
        "position": {"x": position.x, "y": position.y},
        "direction": direction
    }

static func from_dict(data: Dictionary) -> DoorPlacement:
    var pos = Vector2i(data.position.x, data.position.y)
    return DoorPlacement.new(pos, data.direction)
```

For FurniturePlacement:
```gdscript
func to_dict() -> Dictionary:
    return {
        "furniture_id": furniture.id if furniture else "",
        "position": {"x": position.x, "y": position.y},
        "rotation": rotation
    }

static func from_dict(data: Dictionary) -> FurniturePlacement:
    var pos = Vector2i(data.position.x, data.position.y)
    var furn_id = data.get("furniture_id", "")
    var furn: FurnitureResource = null
    if furn_id != "":
        furn = FurnitureRegistry.get_instance().get_furniture(furn_id)
    var rot = data.get("rotation", 0)
    return FurniturePlacement.new(furn, pos, rot)
```

IMPORTANT: Store Vector2i as {"x": N, "y": N} objects, not arrays. JSON.parse_string() doesn't preserve array types correctly in GDScript.

IMPORTANT: FurniturePlacement.from_dict() must look up the FurnitureResource from FurnitureRegistry by ID. If furniture not found, return placement with null furniture (graceful degradation).
  </action>
  <verify>
Read RoomInstance.gd and confirm both inner classes have to_dict() and static from_dict() methods.
  </verify>
  <done>
DoorPlacement and FurniturePlacement have working serialization methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add serialization methods to RoomInstance</name>
  <files>scripts/storage/RoomInstance.gd</files>
  <action>
Add to_dict() and static from_dict() methods to RoomInstance class.

For to_dict():
```gdscript
func to_dict() -> Dictionary:
    var doors_arr: Array = []
    for door in doors:
        doors_arr.append(door.to_dict())

    var furniture_arr: Array = []
    for furn in furniture:
        furniture_arr.append(furn.to_dict())

    var walls_arr: Array = []
    for wall in walls:
        walls_arr.append({"x": wall.x, "y": wall.y})

    return {
        "id": id,
        "room_type_id": room_type_id,
        "bounding_box": {
            "x": bounding_box.position.x,
            "y": bounding_box.position.y,
            "width": bounding_box.size.x,
            "height": bounding_box.size.y
        },
        "walls": walls_arr,
        "doors": doors_arr,
        "furniture": furniture_arr
    }
```

For from_dict() (static method):
```gdscript
static func from_dict(data: Dictionary) -> RoomInstance:
    var room = RoomInstance.new(data.id, data.room_type_id)

    # Restore bounding_box
    var bbox = data.bounding_box
    room.bounding_box = Rect2i(bbox.x, bbox.y, bbox.width, bbox.height)

    # Restore walls
    room.walls = []
    for wall_data in data.walls:
        room.walls.append(Vector2i(wall_data.x, wall_data.y))

    # Restore doors
    room.doors = []
    for door_data in data.doors:
        room.doors.append(DoorPlacement.from_dict(door_data))

    # Restore furniture
    room.furniture = []
    for furn_data in data.furniture:
        room.furniture.append(FurniturePlacement.from_dict(furn_data))

    return room
```

IMPORTANT: Do NOT emit placement_changed signal during from_dict() - we're loading, not modifying. The current implementation appends directly to arrays without using add_door()/add_furniture() methods.

IMPORTANT: Handle missing keys gracefully with data.get("key", default) where appropriate for forward compatibility.
  </action>
  <verify>
Read RoomInstance.gd and confirm RoomInstance has to_dict() and static from_dict() methods.
  </verify>
  <done>
RoomInstance has complete serialization support for all properties including nested doors and furniture.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add schema version constant</name>
  <files>scripts/storage/RoomInstance.gd</files>
  <action>
Add a class constant for schema versioning at the top of RoomInstance:

```gdscript
const SCHEMA_VERSION := 1
```

Update to_dict() to include the version:
```gdscript
return {
    "schema_version": SCHEMA_VERSION,
    "id": id,
    # ... rest of dict
}
```

Update from_dict() to read and validate version:
```gdscript
static func from_dict(data: Dictionary) -> RoomInstance:
    var version = data.get("schema_version", 1)
    if version > SCHEMA_VERSION:
        push_warning("RoomInstance: Loading data from newer schema version %d (current: %d)" % [version, SCHEMA_VERSION])

    # ... rest of loading
```

This enables future schema migrations when data structure changes.
  </action>
  <verify>
Read RoomInstance.gd and confirm SCHEMA_VERSION constant exists and is used in to_dict() and from_dict().
  </verify>
  <done>
Schema versioning is in place for future migration support.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. RoomInstance.gd contains:
   - SCHEMA_VERSION constant
   - DoorPlacement.to_dict() and DoorPlacement.from_dict()
   - FurniturePlacement.to_dict() and FurniturePlacement.from_dict()
   - RoomInstance.to_dict() and RoomInstance.from_dict()

2. All Vector2i stored as {"x": N, "y": N} objects
3. FurniturePlacement deserializes by looking up FurnitureResource from registry
4. Schema version included in serialized output
</verification>

<success_criteria>
- RoomInstance.to_dict() returns a Dictionary with all room data
- RoomInstance.from_dict(dict) returns a RoomInstance with identical data
- Round-trip: room.to_dict() -> from_dict(dict) produces equivalent room
- No placement_changed signals emitted during from_dict()
- Schema version embedded for future migrations
</success_criteria>

<output>
After completion, create `.planning/phases/03-persistence-infrastructure/03-01-SUMMARY.md`
</output>
