---
phase: 06-door-editing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/room_editing/DoorEditController.gd
  - scripts/RoomManager.gd
autonomous: true

must_haves:
  truths:
    - "DoorEditController tracks active edit mode and current room"
    - "Wall tiles can be tapped to trigger door operations"
    - "RoomManager can check if tile belongs to another room"
  artifacts:
    - path: "scripts/room_editing/DoorEditController.gd"
      provides: "Door edit mode state machine"
      exports: ["enter_edit_mode", "exit_edit_mode", "is_active", "get_current_room"]
    - path: "scripts/RoomManager.gd"
      provides: "Tile occupancy check"
      contains: "is_tile_in_another_room"
  key_links:
    - from: "scripts/room_editing/DoorEditController.gd"
      to: "RoomManager.is_tile_in_another_room"
      via: "static method call"
      pattern: "RoomManager\\.is_tile_in_another_room"
---

<objective>
Create DoorEditController state machine and RoomManager tile occupancy helper.

Purpose: Establish infrastructure for door editing mode with tap detection on wall tiles and ability to check adjacent room occupancy.

Output: DoorEditController class with edit mode state management, wall tile tap detection via Area2D, and RoomManager helper for tile ownership checks.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-door-editing/06-RESEARCH.md
@scripts/room_editing/FurnitureEditController.gd
@scripts/RoomManager.gd
@scripts/storage/RoomInstance.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tile occupancy helper to RoomManager</name>
  <files>scripts/RoomManager.gd</files>
  <action>
Add helper method to check if a tile belongs to any room other than the specified one.

Add these methods to RoomManager:

```gdscript
## Check if a tile position is inside any room other than the excluded one
func is_tile_in_another_room(tile: Vector2i, exclude_room: RoomInstance) -> bool:
    for room in _rooms:
        if room == exclude_room:
            continue
        if _is_tile_in_room(tile, room):
            return true
    return false

func _is_tile_in_room(tile: Vector2i, room: RoomInstance) -> bool:
    var bbox = room.bounding_box
    if tile.x < bbox.position.x or tile.x >= bbox.position.x + bbox.size.x:
        return false
    if tile.y < bbox.position.y or tile.y >= bbox.position.y + bbox.size.y:
        return false
    return true
```

These will be used by DoorOperation to validate door placement doesn't open into adjacent rooms.
  </action>
  <verify>Grep for `is_tile_in_another_room` in RoomManager.gd shows the function</verify>
  <done>RoomManager has is_tile_in_another_room method that checks tile against all rooms except excluded one</done>
</task>

<task type="auto">
  <name>Task 2: Create DoorEditController with state management and tap detection</name>
  <files>scripts/room_editing/DoorEditController.gd</files>
  <action>
Create DoorEditController following the FurnitureEditController pattern.

Key elements:
1. Signals for door operations and mode changes:
   - `door_added(room: RoomInstance, door: RoomInstance.DoorPlacement)`
   - `door_removed(room: RoomInstance, door: RoomInstance.DoorPlacement)`
   - `door_add_failed(reason: String)`
   - `door_remove_failed(reason: String)`
   - `wall_tile_tapped(position: Vector2i, is_door: bool)`
   - `mode_exited`

2. State variables:
   - `_active: bool` - whether door edit mode is active
   - `_current_room: RoomInstance` - the room being edited
   - `_wall_areas: Dictionary` - position -> Area2D for wall tap detection

3. Tap detection using same thresholds as FurnitureEditController:
   - `TAP_DISTANCE_THRESHOLD := 20.0`
   - `TAP_TIME_THRESHOLD := 300`

4. Methods:
   - `enter_edit_mode(room: RoomInstance)` - activate mode, create wall areas
   - `exit_edit_mode()` - cleanup areas, emit mode_exited
   - `is_active()` - returns _active
   - `get_current_room()` - returns _current_room

5. Wall area creation:
   - Create Area2D with CollisionPolygon2D for EACH wall tile in room.walls
   - Use IsometricMath.tile_to_world() for polygon vertices (same as FurnitureEditController)
   - Set input_pickable = true (CRITICAL)
   - Connect input_event to handle tap detection

6. Tap handling:
   - On wall tap, determine if position is existing door or available wall
   - Emit `wall_tile_tapped(position, is_door)` signal
   - is_door = true if position matches any room.doors[].position

Important: Set mouse_filter = MOUSE_FILTER_IGNORE since this is a Control covering full rect.

Follow FurnitureEditController for dual desktop/mobile input handling pattern.
  </action>
  <verify>File exists with class_name DoorEditController and enter_edit_mode/exit_edit_mode methods</verify>
  <done>DoorEditController can enter/exit edit mode, creates tap areas for all wall tiles, emits wall_tile_tapped with door status</done>
</task>

</tasks>

<verification>
1. RoomManager.gd contains is_tile_in_another_room method
2. DoorEditController.gd exists with required signals and methods
3. DoorEditController follows FurnitureEditController patterns for tap detection
4. No syntax errors (Godot project opens without errors)
</verification>

<success_criteria>
- RoomManager can check tile occupancy against all other rooms
- DoorEditController can enter/exit edit mode
- Wall tiles have tap detection areas created when entering edit mode
- Tapping wall tiles emits signal indicating if position is existing door or not
</success_criteria>

<output>
After completion, create `.planning/phases/06-door-editing/06-01-SUMMARY.md`
</output>
