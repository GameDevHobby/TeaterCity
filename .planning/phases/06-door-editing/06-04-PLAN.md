---
phase: 06-door-editing
plan: 04
type: execute
wave: 3
depends_on: ["06-02", "06-03"]
files_modified:
  - scripts/room_editing/DoorEditHighlight.gd
  - scripts/room_editing/RoomEditMenu.gd
  - scripts/Main.gd
autonomous: true

must_haves:
  truths:
    - "Edit Room button enters door edit mode"
    - "Wall tiles show visual highlight in door edit mode"
    - "Existing doors show distinct highlight from available walls"
    - "Door add/remove updates navigation mesh"
  artifacts:
    - path: "scripts/room_editing/DoorEditHighlight.gd"
      provides: "Visual feedback for door editing"
      exports: ["set_controller"]
    - path: "scripts/Main.gd"
      provides: "Signal wiring for door edit mode"
      contains: ["DoorEditController", "door_added", "door_removed"]
  key_links:
    - from: "scripts/room_editing/RoomEditMenu.gd"
      to: "edit_room_pressed"
      via: "signal emission"
      pattern: "edit_room_pressed\\.emit"
    - from: "scripts/Main.gd"
      to: "DoorEditController"
      via: "signal connections"
      pattern: "_door_edit_controller\\."
    - from: "scripts/Main.gd"
      to: "NavigationOperation"
      via: "nav update after door change"
      pattern: "_navigation_op\\.update_room_navigation"
---

<objective>
Create visual highlight for door editing and wire everything together in Main.gd.

Purpose: Enable full door editing workflow from menu entry through visual feedback and navigation mesh updates.

Output: DoorEditHighlight Control for wall tile visuals, RoomEditMenu wiring, Main.gd integration with navigation updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-door-editing/06-RESEARCH.md
@.planning/phases/06-door-editing/06-02-SUMMARY.md
@.planning/phases/06-door-editing/06-03-SUMMARY.md
@scripts/room_editing/FurnitureSelectionHighlight.gd
@scripts/room_editing/RoomEditMenu.gd
@scripts/Main.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DoorEditHighlight for wall tile visualization</name>
  <files>scripts/room_editing/DoorEditHighlight.gd</files>
  <action>
Create DoorEditHighlight following FurnitureSelectionHighlight pattern.

```gdscript
class_name DoorEditHighlight
extends Control

## Visual highlight for door editing mode.
## Shows wall tiles as available for door placement, existing doors as removable.
## Must be wrapped in CanvasLayer by Main.gd for correct screen-space rendering.

# Colors for different states
const WALL_COLOR := Color(0.8, 0.6, 0.2, 0.3)  # Warm orange for available walls
const DOOR_COLOR := Color(0.6, 0.2, 0.8, 0.4)  # Purple for existing doors
const INVALID_COLOR := Color(0.5, 0.5, 0.5, 0.2)  # Gray for invalid positions

# Controller reference (set by Main.gd)
var _controller: DoorEditController = null


func _ready() -> void:
    # Will be hidden until door edit mode is active
    pass


func set_controller(controller: DoorEditController) -> void:
    if _controller != null:
        # Disconnect from previous controller
        if _controller.mode_exited.is_connected(_on_mode_exited):
            _controller.mode_exited.disconnect(_on_mode_exited)

    _controller = controller

    if _controller != null:
        _controller.mode_exited.connect(_on_mode_exited)


func _on_mode_exited() -> void:
    queue_redraw()


func _draw() -> void:
    if _controller == null or not _controller.is_active():
        return

    var room := _controller.get_current_room()
    if room == null:
        return

    var viewport := get_viewport()

    # Draw all wall tiles
    for wall_pos in room.walls:
        # Check if this is a door position
        var is_door = false
        for door in room.doors:
            if door.position == wall_pos:
                is_door = true
                break

        if is_door:
            # Existing door - show as removable
            RoomBuildDrawing.draw_tile_highlight(self, wall_pos, DOOR_COLOR, viewport)
        else:
            # Available wall - show as potential door location
            RoomBuildDrawing.draw_tile_highlight(self, wall_pos, WALL_COLOR, viewport)
```

This provides visual feedback showing:
- Orange tiles: Wall positions where doors can be added
- Purple tiles: Existing doors that can be removed
  </action>
  <verify>File exists with class_name DoorEditHighlight and _draw method with wall iteration</verify>
  <done>DoorEditHighlight draws wall tiles in orange, existing doors in purple</done>
</task>

<task type="auto">
  <name>Task 2: Wire door edit mode in Main.gd</name>
  <files>scripts/Main.gd</files>
  <action>
Add DoorEditController and DoorEditHighlight integration to Main.gd.

1. Add instance variables (near other edit controllers):
```gdscript
var _door_edit_controller: DoorEditController = null
var _door_edit_highlight: DoorEditHighlight = null
var _door_edit_layer: CanvasLayer = null
```

2. In _ready(), create door edit components (after furniture edit setup):
```gdscript
# Door edit controller
_door_edit_controller = DoorEditController.new()
_door_edit_controller.name = "DoorEditController"
_door_edit_controller.mouse_filter = Control.MOUSE_FILTER_IGNORE
_door_edit_controller.set_anchors_preset(Control.PRESET_FULL_RECT)
add_child(_door_edit_controller)

# Door edit highlight layer
_door_edit_layer = CanvasLayer.new()
_door_edit_layer.name = "DoorEditLayer"
_door_edit_layer.layer = 0  # Same as furniture edit layer
add_child(_door_edit_layer)

# Door edit highlight
_door_edit_highlight = DoorEditHighlight.new()
_door_edit_highlight.name = "DoorEditHighlight"
_door_edit_highlight.mouse_filter = Control.MOUSE_FILTER_IGNORE
_door_edit_highlight.set_anchors_preset(Control.PRESET_FULL_RECT)
_door_edit_highlight.set_controller(_door_edit_controller)
_door_edit_layer.add_child(_door_edit_highlight)

# Connect door edit signals
_door_edit_controller.door_added.connect(_on_door_added)
_door_edit_controller.door_removed.connect(_on_door_removed)
_door_edit_controller.door_add_failed.connect(_on_door_add_failed)
_door_edit_controller.door_remove_failed.connect(_on_door_remove_failed)
_door_edit_controller.mode_exited.connect(_on_door_edit_mode_exited)
```

3. Connect RoomEditMenu.edit_room_pressed to enter door edit mode:
```gdscript
# In _ready or where menu signals are connected
_room_edit_menu.edit_room_pressed.connect(_on_edit_room_pressed)
```

4. Add handler methods:
```gdscript
func _on_edit_room_pressed(room: RoomInstance) -> void:
    # Exit furniture edit if active
    if _furniture_edit_controller and _furniture_edit_controller.is_active():
        _furniture_edit_controller.exit_edit_mode()

    # Hide room menu
    _room_edit_menu.hide()

    # Enter door edit mode
    _door_edit_controller.enter_edit_mode(room)
    _door_edit_highlight.queue_redraw()


func _on_door_added(room: RoomInstance, door: RoomInstance.DoorPlacement) -> void:
    # Create door visuals
    var tilemap = _room_build_controller.get_tilemap_layer()
    if tilemap:
        var door_op = DoorOperation.new()
        door_op.create_door_visuals(door, tilemap)

    # Update navigation mesh
    _update_navigation_for_room(room)

    # Refresh highlight
    _door_edit_highlight.queue_redraw()


func _on_door_removed(room: RoomInstance, door: RoomInstance.DoorPlacement) -> void:
    # Remove door visuals and restore wall
    var tilemap = _room_build_controller.get_tilemap_layer()
    if tilemap:
        var door_op = DoorOperation.new()
        door_op.remove_door_visuals(door, room, tilemap)

    # Update navigation mesh
    _update_navigation_for_room(room)

    # Refresh highlight
    _door_edit_highlight.queue_redraw()


func _on_door_add_failed(reason: String) -> void:
    print("Door add failed: ", reason)
    # TODO: Show inline error like furniture delete failed


func _on_door_remove_failed(reason: String) -> void:
    print("Door remove failed: ", reason)
    # TODO: Show inline error


func _on_door_edit_mode_exited() -> void:
    _door_edit_highlight.queue_redraw()


func _update_navigation_for_room(room: RoomInstance) -> void:
    var tilemap = _room_build_controller.get_tilemap_layer()
    if tilemap:
        var nav_op = NavigationOperation.new()
        nav_op.update_room_navigation(room, tilemap)
    # Notify targets of navigation change
    Targets.notify_navigation_changed()
```

Note: If `_room_edit_menu` doesn't have edit_room_pressed connected yet, find where it's created and add the connection.
  </action>
  <verify>Main.gd contains _door_edit_controller, _on_edit_room_pressed, and _on_door_added methods</verify>
  <done>Main.gd wires door edit mode: menu entry, visual creation, navigation updates, signal handling</done>
</task>

</tasks>

<verification>
1. DoorEditHighlight.gd exists and draws wall tiles with distinct colors
2. Main.gd creates DoorEditController and DoorEditHighlight
3. edit_room_pressed signal connected to enter door edit mode
4. door_added triggers visual creation and navigation update
5. door_removed triggers wall restoration and navigation update
6. Targets.notify_navigation_changed() called after door changes
</verification>

<success_criteria>
- Edit Room button enters door edit mode
- Wall tiles highlighted in orange during door edit mode
- Existing doors highlighted in purple during door edit mode
- Adding door creates visual and updates navigation
- Removing door restores wall and updates navigation
- Patrons can path through new doors after navigation update
</success_criteria>

<output>
After completion, create `.planning/phases/06-door-editing/06-04-SUMMARY.md`
</output>
