---
phase: 06-door-editing
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - scripts/room_building/operations/DoorOperation.gd
  - scripts/room_editing/DoorEditController.gd
autonomous: true

must_haves:
  truths:
    - "Door can be added to valid wall positions"
    - "Door placement blocked if adjacent tile is in another room"
    - "Door placement blocked if door already exists at position"
    - "Door placement blocked if exceeds room type maximum"
  artifacts:
    - path: "scripts/room_building/operations/DoorOperation.gd"
      provides: "Edit-mode door validation"
      contains: "can_place_door_edit"
    - path: "scripts/room_editing/DoorEditController.gd"
      provides: "Add door operation"
      contains: "add_door"
  key_links:
    - from: "scripts/room_editing/DoorEditController.gd"
      to: "DoorOperation.can_place_door_edit"
      via: "validation before add"
      pattern: "_door_operation\\.can_place_door_edit"
    - from: "scripts/room_building/operations/DoorOperation.gd"
      to: "RoomManager.is_tile_in_another_room"
      via: "adjacent tile check"
      pattern: "RoomManager\\.is_tile_in_another_room"
---

<objective>
Implement door add operation with full validation including adjacent room check.

Purpose: Allow players to add doors to wall tiles with proper validation ensuring doors only open to empty space, not into adjacent rooms.

Output: DoorOperation extended with can_place_door_edit(), DoorEditController with add_door() method that validates, creates door, updates navigation, and triggers auto-save.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-door-editing/06-RESEARCH.md
@.planning/phases/06-door-editing/06-01-SUMMARY.md
@scripts/room_building/operations/DoorOperation.gd
@scripts/room_editing/DoorEditController.gd
@scripts/RoomManager.gd
@scripts/storage/RoomInstance.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend DoorOperation with edit-mode validation</name>
  <files>scripts/room_building/operations/DoorOperation.gd</files>
  <action>
Add validation method for door placement during edit mode. This extends existing DoorOperation with additional checks for:
1. Adjacent room occupancy (DOOR-03 requirement)
2. Existing door at position
3. Room type maximum door count

Add these methods to DoorOperation:

```gdscript
## Validate door placement for edit mode (stricter than build mode)
## Returns Dictionary with { can_place: bool, reason: String }
func can_place_door_edit(position: Vector2i, room: RoomInstance) -> Dictionary:
    var result = { "can_place": true, "reason": "" }

    # Check if position is valid wall tile (2-3 neighbors)
    if not is_valid_door_position(position, room):
        result.can_place = false
        result.reason = "Invalid wall position for door"
        return result

    # Check if door already exists at this position
    for door in room.doors:
        if door.position == position:
            result.can_place = false
            result.reason = "Door already exists here"
            return result

    # Check room type maximum door count
    var room_type = RoomTypeRegistry.get_instance().get_room_type(room.room_type_id)
    if room_type and room_type.door_count_max > 0:
        if room.doors.size() >= room_type.door_count_max:
            result.can_place = false
            result.reason = "Maximum %d door(s) reached" % room_type.door_count_max
            return result

    # Check adjacent tile (outside door) for other rooms
    var direction = determine_door_direction(position, room)
    var outside_tile = _get_outside_tile(position, direction)

    if RoomManager.is_tile_in_another_room(outside_tile, room):
        result.can_place = false
        result.reason = "Cannot place door into adjacent room"
        return result

    return result

## Get the tile position outside the door based on direction
func _get_outside_tile(door_pos: Vector2i, direction: int) -> Vector2i:
    # Direction: 0=North, 1=East, 2=South, 3=West
    match direction:
        0: return door_pos + Vector2i(0, -1)  # North: outside is y-1
        1: return door_pos + Vector2i(1, 0)   # East: outside is x+1
        2: return door_pos + Vector2i(0, 1)   # South: outside is y+1
        3: return door_pos + Vector2i(-1, 0)  # West: outside is x-1
    return door_pos
```

Note: RoomManager is an autoload singleton, so call it directly without instance.
  </action>
  <verify>Grep for `can_place_door_edit` in DoorOperation.gd shows the function with RoomManager call</verify>
  <done>DoorOperation validates door position against wall rules, existing doors, max count, and adjacent room occupancy</done>
</task>

<task type="auto">
  <name>Task 2: Add door operation to DoorEditController</name>
  <files>scripts/room_editing/DoorEditController.gd</files>
  <action>
Add method to create a door at a tapped wall position.

Add to DoorEditController:

1. Add operation references at top with other vars:
```gdscript
var _door_operation: DoorOperation = null
var _navigation_operation: NavigationOperation = null
```

2. Initialize operations in enter_edit_mode():
```gdscript
if _door_operation == null:
    _door_operation = DoorOperation.new()
if _navigation_operation == null:
    _navigation_operation = NavigationOperation.new()
```

3. Add add_door method:
```gdscript
## Add a door at the specified wall position
## Returns true if door was added, false if blocked
func add_door(position: Vector2i) -> bool:
    if not _active or _current_room == null:
        return false

    # Validate placement
    var validation = _door_operation.can_place_door_edit(position, _current_room)
    if not validation.can_place:
        door_add_failed.emit(validation.reason)
        return false

    # Determine direction from position
    var direction = _door_operation.determine_door_direction(position, _current_room)

    # Create door placement
    var door = RoomInstance.DoorPlacement.new(position, direction)
    _current_room.doors.append(door)

    # Create door visuals (need tilemap reference - emit signal for Main to handle)
    door_added.emit(_current_room, door)

    # Trigger auto-save
    _current_room.placement_changed.emit()

    return true
```

4. Add method to handle wall tap and decide action:
```gdscript
## Called when wall tile is tapped - routes to add or remove based on is_door
func handle_wall_tap(position: Vector2i, is_door: bool) -> void:
    if is_door:
        # Will be implemented in Plan 03
        pass
    else:
        add_door(position)
```

5. Connect wall_tile_tapped signal to handle_wall_tap in enter_edit_mode (or _ready):
```gdscript
# In _ready or enter_edit_mode
if not wall_tile_tapped.is_connected(handle_wall_tap):
    wall_tile_tapped.connect(handle_wall_tap)
```

Note: Visual creation and navigation update will be wired in Plan 04 when Main.gd integration happens.
  </action>
  <verify>DoorEditController has add_door method that calls _door_operation.can_place_door_edit</verify>
  <done>DoorEditController can add doors with validation, emits door_added signal for visual creation</done>
</task>

</tasks>

<verification>
1. DoorOperation.can_place_door_edit validates all four conditions
2. DoorEditController.add_door uses validation before creating door
3. door_added signal emitted after successful add
4. placement_changed emitted to trigger auto-save
5. No syntax errors
</verification>

<success_criteria>
- Doors can only be placed on valid wall tiles (2-3 neighbors)
- Doors blocked if position already has door
- Doors blocked if room at max door count
- Doors blocked if adjacent tile is in another room (DOOR-03)
- Successful add triggers auto-save via placement_changed signal
</success_criteria>

<output>
After completion, create `.planning/phases/06-door-editing/06-02-SUMMARY.md`
</output>
