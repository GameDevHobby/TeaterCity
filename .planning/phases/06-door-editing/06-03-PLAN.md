---
phase: 06-door-editing
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - scripts/room_building/operations/DoorOperation.gd
  - scripts/room_editing/DoorEditController.gd
autonomous: true

must_haves:
  truths:
    - "Player can remove existing doors"
    - "Door removal blocked if at minimum door count for room type"
    - "Wall tile restored when door removed"
    - "Terrain connections updated around restored wall"
  artifacts:
    - path: "scripts/room_building/operations/DoorOperation.gd"
      provides: "Door removal validation and wall restoration"
      contains: ["can_remove_door", "remove_door_visuals"]
    - path: "scripts/room_editing/DoorEditController.gd"
      provides: "Remove door operation"
      contains: "remove_door"
  key_links:
    - from: "scripts/room_editing/DoorEditController.gd"
      to: "DoorOperation.can_remove_door"
      via: "validation before remove"
      pattern: "_door_operation\\.can_remove_door"
---

<objective>
Implement door removal operation with validation and wall restoration.

Purpose: Allow players to remove doors while respecting room type minimum requirements and properly restoring wall tiles with terrain connections.

Output: DoorOperation extended with can_remove_door() and remove_door_visuals(), DoorEditController with remove_door() method that validates, removes door, restores wall, and triggers auto-save.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-door-editing/06-RESEARCH.md
@.planning/phases/06-door-editing/06-01-SUMMARY.md
@scripts/room_building/operations/DoorOperation.gd
@scripts/room_editing/DoorEditController.gd
@scripts/storage/RoomInstance.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add door removal validation to DoorOperation</name>
  <files>scripts/room_building/operations/DoorOperation.gd</files>
  <action>
Add validation method for door removal.

Add to DoorOperation:

```gdscript
## Validate door removal
## Returns Dictionary with { can_remove: bool, reason: String }
func can_remove_door(room: RoomInstance) -> Dictionary:
    var result = { "can_remove": true, "reason": "" }

    # Check room type minimum door count
    var room_type = RoomTypeRegistry.get_instance().get_room_type(room.room_type_id)
    if room_type:
        var min_doors = room_type.door_count_min if room_type.door_count_min > 0 else 1
        if room.doors.size() <= min_doors:
            result.can_remove = false
            result.reason = "Minimum %d door(s) required" % min_doors
            return result

    return result
```

Note: Most room types have door_count_min of 1 - rooms need at least one door for patron access.
  </action>
  <verify>Grep for `can_remove_door` in DoorOperation.gd shows the function</verify>
  <done>DoorOperation validates room type minimum door count before allowing removal</done>
</task>

<task type="auto">
  <name>Task 2: Add wall restoration method to DoorOperation</name>
  <files>scripts/room_building/operations/DoorOperation.gd</files>
  <action>
Add method to restore wall tile after door removal.

Add to DoorOperation:

```gdscript
## Remove door visuals and restore wall tile
## Must be called BEFORE removing door from room.doors array
func remove_door_visuals(door: RoomInstance.DoorPlacement, room: RoomInstance, tilemap_layer: TileMapLayer) -> void:
    var tilemap_pos = _ui_to_tilemap_coords(door.position, tilemap_layer)

    # Erase the door tile
    tilemap_layer.erase_cell(tilemap_pos)

    # Collect all wall positions for this room (excluding other doors and the door being removed)
    var wall_tilemap_positions: Array[Vector2i] = []
    for wall_pos in room.walls:
        var is_other_door = false
        for d in room.doors:
            if d != door and d.position == wall_pos:
                is_other_door = true
                break
        if not is_other_door:
            wall_tilemap_positions.append(_ui_to_tilemap_coords(wall_pos, tilemap_layer))

    # Re-place all walls with terrain connect to restore proper tile transitions
    # This ensures the restored wall tile connects properly with neighbors
    if wall_tilemap_positions.size() > 0:
        # First erase all wall tiles
        for pos in wall_tilemap_positions:
            tilemap_layer.erase_cell(pos)
        # Then re-place with terrain connect
        tilemap_layer.set_cells_terrain_connect(wall_tilemap_positions, TERRAIN_SET, TERRAIN_INDEX)
```

This uses terrain auto-tiling to ensure wall corners and edges display correctly after door removal.
  </action>
  <verify>Grep for `remove_door_visuals` in DoorOperation.gd shows the function with set_cells_terrain_connect</verify>
  <done>DoorOperation can remove door visuals and restore wall with proper terrain connections</done>
</task>

<task type="auto">
  <name>Task 3: Add remove_door method to DoorEditController</name>
  <files>scripts/room_editing/DoorEditController.gd</files>
  <action>
Add method to remove a door at a tapped position.

Add to DoorEditController:

```gdscript
## Remove the door at the specified position
## Returns true if door was removed, false if blocked
func remove_door(position: Vector2i) -> bool:
    if not _active or _current_room == null:
        return false

    # Find the door at this position
    var door_to_remove: RoomInstance.DoorPlacement = null
    var door_index: int = -1
    for i in range(_current_room.doors.size()):
        if _current_room.doors[i].position == position:
            door_to_remove = _current_room.doors[i]
            door_index = i
            break

    if door_to_remove == null:
        door_remove_failed.emit("No door at this position")
        return false

    # Validate removal
    var validation = _door_operation.can_remove_door(_current_room)
    if not validation.can_remove:
        door_remove_failed.emit(validation.reason)
        return false

    # Store reference before removal
    var removed_door = door_to_remove

    # Remove from data array
    _current_room.doors.remove_at(door_index)

    # Emit signal for visual removal (Main.gd handles tilemap)
    door_removed.emit(_current_room, removed_door)

    # Trigger auto-save
    _current_room.placement_changed.emit()

    return true
```

Update handle_wall_tap to call remove_door:

```gdscript
func handle_wall_tap(position: Vector2i, is_door: bool) -> void:
    if is_door:
        remove_door(position)
    else:
        add_door(position)
```

Note: Visual removal (remove_door_visuals) will be called by Main.gd when it receives the door_removed signal.
  </action>
  <verify>DoorEditController has remove_door method that calls _door_operation.can_remove_door</verify>
  <done>DoorEditController can remove doors with validation, emits door_removed signal for visual update</done>
</task>

</tasks>

<verification>
1. DoorOperation.can_remove_door checks minimum door count
2. DoorOperation.remove_door_visuals uses terrain connect for wall restoration
3. DoorEditController.remove_door validates before removal
4. door_removed signal emitted after successful removal
5. placement_changed emitted to trigger auto-save
6. handle_wall_tap routes to add or remove based on is_door flag
</verification>

<success_criteria>
- Door removal blocked if at room type minimum count
- Removing door erases door tile from tilemap
- Wall tile restored with proper terrain connections
- Successful removal triggers auto-save via placement_changed signal
- Tapping existing door triggers remove, tapping wall triggers add
</success_criteria>

<output>
After completion, create `.planning/phases/06-door-editing/06-03-SUMMARY.md`
</output>
