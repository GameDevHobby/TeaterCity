---
phase: 13-theater-state-machine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/state_machine/TheaterStateConfig.gd
  - scripts/storage/RoomInstance.gd
  - scripts/room_building/RoomBuildController.gd
autonomous: true

must_haves:
  truths:
    - "Theater rooms have a canonical five-state graph (idle, scheduled, previews, playing, cleaning)"
    - "Newly built theater rooms initialize a state machine automatically"
    - "Restored theater rooms rehydrate their saved state machine automatically"
    - "State changes from freshly initialized rooms emit placement_changed for auto-save"
  artifacts:
    - path: "scripts/state_machine/TheaterStateConfig.gd"
      provides: "Reusable theater state definitions"
      exports: ["TheaterStateConfig"]
      min_lines: 35
    - path: "scripts/storage/RoomInstance.gd"
      provides: "Consistent state-machine signal wiring for fresh and restored initialization"
      contains: "initialize_state_machine"
    - path: "scripts/room_building/RoomBuildController.gd"
      provides: "Theater state-machine initialization at room create/restore boundaries"
      contains: "_on_complete_pressed, _on_room_restored"
  key_links:
    - from: "scripts/room_building/RoomBuildController.gd"
      to: "scripts/state_machine/TheaterStateConfig.gd"
      via: "builds state definitions for theater_auditorium"
      pattern: "TheaterStateConfig"
    - from: "scripts/storage/RoomInstance.gd"
      to: "RoomStateMachine.state_changed"
      via: "signal forwarding"
      pattern: "state_changed\.connect\(_on_state_machine_changed\)"
---

<objective>
Implement theater-specific state definitions and initialization wiring for both new and restored rooms.

Purpose: Deliver the foundation of THTR-01/THTR-02 so theater rooms consistently own a configured state machine before runtime ticking begins.
Output: TheaterStateConfig helper plus RoomInstance/RoomBuildController wiring that initializes theater state machines in all room lifecycle paths.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-theater-state-machine/13-RESEARCH.md
@.planning/phases/11-timer-state-foundation/11-01-SUMMARY.md
@.planning/phases/11-timer-state-foundation/11-02-SUMMARY.md
@scripts/state_machine/RoomStateMachine.gd
@scripts/storage/RoomInstance.gd
@scripts/room_building/RoomBuildController.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TheaterStateConfig helper</name>
  <files>scripts/state_machine/TheaterStateConfig.gd</files>
  <action>
Create `TheaterStateConfig` as a RefCounted helper that centralizes theater state graph creation.

Implement constants for canonical durations and expose a builder function that returns `Dictionary[String, StateDefinition]` containing exactly:
- `idle` (duration 0, no next)
- `scheduled` (timed, next=`previews`)
- `previews` (timed, next=`playing`)
- `playing` (timed, next=`cleaning`)
- `cleaning` (timed, next=`idle`)

Add one explicit helper for room filtering (for example `is_theater_room(room: RoomInstance)` or `is_theater_room_type(room_type_id: String)`) keyed to `theater_auditorium` so downstream code does not hardcode string checks in multiple files.

Durations should be configurable via arguments/default constants (do not hardcode values in callers), and the file should not start transitions itself.
  </action>
  <verify>
Open `scripts/state_machine/TheaterStateConfig.gd` and confirm the returned dictionary always includes all five states with the exact transition chain `scheduled -> previews -> playing -> cleaning -> idle`.
  </verify>
  <done>
TheaterStateConfig exists and can generate a complete, reusable theater state-definition dictionary without side effects.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire theater state-machine initialization for new and restored rooms</name>
  <files>scripts/storage/RoomInstance.gd, scripts/room_building/RoomBuildController.gd</files>
  <action>
Update `RoomInstance.initialize_state_machine()` so signal forwarding is consistent for both fresh and restored initialization paths:
- Connect `state_machine.state_changed` to `_on_state_machine_changed` in fresh initialization path (currently only restore path connects).
- Guard against duplicate signal connections.

Update `RoomBuildController` to initialize theater state machines in both lifecycle boundaries:
- Newly completed rooms (`_on_complete_pressed`) before `register_room`.
- Restored rooms (`_on_room_restored`) before visuals/tick consumers rely on state.

Use TheaterStateConfig for definition creation and explicitly transition uninitialized theater machines to `idle` after definitions are set. Do not initialize state machines for non-theater room types.
  </action>
  <verify>
Run:
`godot --headless --path . --quit`

Then perform a quick runtime check in editor/headless script flow:
1. Build a `theater_auditorium` room and confirm `room.state_machine.current_state == "idle"` after completion.
2. Save/reload and confirm restored theater room still has non-null `state_machine`.
3. Trigger one manual transition and confirm `RoomInstance.state_changed` and `placement_changed` still emit.
  </verify>
  <done>
Theater rooms always have initialized state machines on create/restore, start in idle when fresh, and propagate state-change signals for persistence hooks.
  </done>
</task>

</tasks>

<verification>
1. TheaterStateConfig returns all five required states with correct next-state wiring.
2. RoomInstance connects state-machine signals in both fresh and restore initialization paths.
3. RoomBuildController initializes theater state machines for both new and restored theater rooms.
4. Non-theater rooms remain unaffected (no forced state-machine initialization).
5. Project parses cleanly in headless Godot run.
</verification>

<success_criteria>
- [ ] `scripts/state_machine/TheaterStateConfig.gd` exists and exports `TheaterStateConfig`
- [ ] Theater state graph includes idle, scheduled, previews, playing, cleaning
- [ ] Fresh theater rooms initialize to `idle`
- [ ] Restored theater rooms rehydrate state machine definitions correctly
- [ ] `RoomInstance` state-machine signal forwarding works in fresh + restored paths
</success_criteria>

<output>
After completion, create `.planning/phases/13-theater-state-machine/13-01-SUMMARY.md`
</output>
