---
phase: 13-theater-state-machine
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - scripts/Main.gd
autonomous: true

must_haves:
  truths:
    - "Theater room states progress automatically at runtime without manual transition calls"
    - "Players can see each theater room's current state in-game"
    - "State indicators stay in sync when state changes and when rooms are removed"
  artifacts:
    - path: "scripts/Main.gd"
      provides: "Runtime theater ticking loop and visual state-indicator orchestration"
      contains: "_process, room lifecycle signal handlers"
      min_lines: 70
  key_links:
    - from: "scripts/Main.gd"
      to: "RoomStateMachine.update()"
      via: "runtime tick"
      pattern: "state_machine\.update\(\)"
    - from: "scripts/Main.gd"
      to: "StateDebugLabel"
      via: "label set_state_machine + screen positioning"
      pattern: "StateDebugLabel"
---

<objective>
Add runtime theater ticking and state visibility in the main gameplay loop.

Purpose: Fulfill the observable part of THTR-01/THTR-02 so theater states advance automatically and are visible to the player during normal play.
Output: Main-level orchestration that updates theater state machines each frame (or fixed cadence) and manages per-room state labels.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-theater-state-machine/13-RESEARCH.md
@.planning/phases/13-theater-state-machine/13-01-SUMMARY.md
@scripts/Main.gd
@scripts/ui/StateDebugLabel.gd
@scripts/RoomManager.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add theater runtime ticking loop in Main</name>
  <files>scripts/Main.gd</files>
  <action>
Add a runtime update path in `Main.gd` (`_process` or a fixed-interval tick) that iterates current rooms and calls `room.state_machine.update()` for theater rooms only.

Requirements for this loop:
- Filter by theater room type using the helper introduced in Plan 01 (avoid duplicating room-type string literals where possible).
- Skip null or uninitialized state machines safely.
- Keep loop lightweight and deterministic (no per-frame allocations that scale with room count).
- Do not change behavior for non-theater rooms.

When `update()` causes transitions, rely on existing signal-based save integration (do not add direct save calls from Main).
  </action>
  <verify>
Run project and observe one scheduled theater over time:
1. Theater transitions occur without manual `transition_to` calls.
2. Chain progresses in order: `scheduled -> previews -> playing -> cleaning -> idle`.
3. No errors for rooms without state machines.
  </verify>
  <done>
Theater rooms auto-transition at runtime via Main tick loop while non-theater room behavior remains unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add per-theater state indicators with lifecycle-safe cleanup</name>
  <files>scripts/Main.gd</files>
  <action>
In `Main.gd`, add orchestration for per-room state labels using `StateDebugLabel`:
- Create and track one label per theater room.
- Bind each label to its room state machine via `set_state_machine`.
- Position/update labels above each theater room (using existing isometric conversion helpers).
- Ensure labels are created for restored rooms and new rooms.
- Ensure labels are removed/hidden when rooms are deleted or invalidated.

Do not convert the label into a new UI system; reuse the existing `StateDebugLabel` class and current CanvasLayer approach in Main.
  </action>
  <verify>
Manual play verification:
1. At least one theater room shows state text while active.
2. Label text changes immediately on state transitions.
3. Deleting a theater room removes its label without orphan nodes/errors.
4. Reloading the save restores labels for restored theater rooms.
  </verify>
  <done>
State indicators are visible, synchronized, and lifecycle-safe for theater rooms through create/restore/delete flows.
  </done>
</task>

</tasks>

<verification>
1. Main contains runtime theater tick logic calling `RoomStateMachine.update()`.
2. Main creates/maintains/removes `StateDebugLabel` instances per theater room.
3. Visual state text updates across timed transitions.
4. No regressions to build/edit/delete room flows.
</verification>

<success_criteria>
- [ ] Theater states transition automatically during active gameplay
- [ ] Players can see current theater state in-game
- [ ] State labels update as transitions occur
- [ ] Room removal/reload does not leak or orphan state labels
- [ ] Headless parse passes without new script errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-theater-state-machine/13-02-SUMMARY.md`
</output>
