---
phase: 11-timer-state-foundation
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - scripts/ui/CircularTimerUI.gd
  - scripts/ui/CircularTimerUI.tscn
  - scripts/ui/StateDebugLabel.gd
autonomous: true

must_haves:
  truths:
    - "Circular progress bar shows countdown time remaining when room selected"
    - "Progress bar displays MM:SS format countdown"
    - "Debug label shows current state name when room selected"
    - "UI elements hide when no room selected or timer inactive"
  artifacts:
    - path: "scripts/ui/CircularTimerUI.gd"
      provides: "Circular progress indicator with countdown"
      exports: ["CircularTimerUI"]
    - path: "scripts/ui/CircularTimerUI.tscn"
      provides: "Scene for circular timer"
    - path: "scripts/ui/StateDebugLabel.gd"
      provides: "Debug label showing state name"
      exports: ["StateDebugLabel"]
  key_links:
    - from: "scripts/ui/CircularTimerUI.gd"
      to: "scripts/storage/TimerState.gd"
      via: "set_timer method"
      pattern: "func set_timer.*TimerState"
---

<objective>
Create visual feedback UI components for timer state display.

Purpose: Players need to see timer progress and current state when a room is selected. This provides the visual layer that makes the timer/state system visible. Per CONTEXT.md decisions: circular progress bar above room center, countdown format (not percentage), debug label visible when selected.

Output: CircularTimerUI component that shows countdown progress, StateDebugLabel that shows current state name. Both appear only when a room is selected and has an active state machine.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-timer-state-foundation/11-CONTEXT.md
@.planning/phases/11-timer-state-foundation/11-RESEARCH.md
@.planning/phases/11-timer-state-foundation/11-01-SUMMARY.md
@scripts/storage/TimerState.gd
@scripts/utils/UIStyleHelper.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CircularTimerUI component</name>
  <files>scripts/ui/CircularTimerUI.gd, scripts/ui/CircularTimerUI.tscn</files>
  <action>
Create a circular progress indicator component using TextureProgressBar.

**CircularTimerUI.tscn** scene structure:
```
CircularTimerUI (Control)
├── TextureProgressBar (TextureProgressBar)
│   - fill_mode = FILL_CLOCKWISE (4)
│   - nine_patch_stretch = false
│   - texture_progress = [circular progress texture - see below]
│   - texture_under = [circular background texture - see below]
└── TimeLabel (Label)
    - anchors: center
    - text: "0:00"
    - horizontal_alignment: CENTER
    - vertical_alignment: CENTER
```

For textures, use Godot's built-in radial progress or create simple circular textures programmatically. Alternative: use custom `_draw()` if TextureProgressBar doesn't work well.

**CircularTimerUI.gd**:
```gdscript
class_name CircularTimerUI
extends Control

@onready var progress_bar: TextureProgressBar = $TextureProgressBar
@onready var time_label: Label = $TimeLabel

var _timer_state: TimerState = null
var _is_showing := false

const RADIUS := 24.0
const THICKNESS := 4.0
const BG_COLOR := Color(0.2, 0.2, 0.25, 0.8)
const FILL_COLOR := Color(0.4, 0.8, 0.4, 1.0)  # Green for active

func _ready() -> void:
    visible = false
    # If using custom draw instead of TextureProgressBar, set up here
    _setup_progress_textures()

func _setup_progress_textures() -> void:
    # Create circular progress textures programmatically
    # This avoids needing external assets
    var size = int(RADIUS * 2 + THICKNESS * 2)
    var center = Vector2(size / 2.0, size / 2.0)

    # Background ring
    var bg_image = Image.create(size, size, false, Image.FORMAT_RGBA8)
    bg_image.fill(Color.TRANSPARENT)
    _draw_ring_to_image(bg_image, center, RADIUS, THICKNESS, BG_COLOR)
    var bg_texture = ImageTexture.create_from_image(bg_image)

    # Progress ring (full circle, TextureProgressBar clips it)
    var progress_image = Image.create(size, size, false, Image.FORMAT_RGBA8)
    progress_image.fill(Color.TRANSPARENT)
    _draw_ring_to_image(progress_image, center, RADIUS, THICKNESS, FILL_COLOR)
    var progress_texture = ImageTexture.create_from_image(progress_image)

    progress_bar.texture_under = bg_texture
    progress_bar.texture_progress = progress_texture
    progress_bar.custom_minimum_size = Vector2(size, size)

func _draw_ring_to_image(image: Image, center: Vector2, radius: float, thickness: float, color: Color) -> void:
    var inner_radius = radius - thickness / 2.0
    var outer_radius = radius + thickness / 2.0
    for x in range(image.get_width()):
        for y in range(image.get_height()):
            var dist = Vector2(x, y).distance_to(center)
            if dist >= inner_radius and dist <= outer_radius:
                image.set_pixel(x, y, color)

func set_timer(timer: TimerState) -> void:
    _timer_state = timer
    _update_visibility()

func show_at_position(world_pos: Vector2) -> void:
    _is_showing = true
    global_position = world_pos - size / 2.0  # Center on position
    _update_visibility()

func hide_timer() -> void:
    _is_showing = false
    visible = false

func _update_visibility() -> void:
    visible = _is_showing and _timer_state != null and _timer_state.is_active

func _process(_delta: float) -> void:
    if not visible or _timer_state == null:
        return

    var remaining = _timer_state.get_remaining()
    var total = _timer_state.duration

    # Update progress (100% = full, 0% = empty)
    if total > 0:
        progress_bar.value = (float(remaining) / total) * 100.0
    else:
        progress_bar.value = 0

    # Update time label (MM:SS format)
    var minutes = remaining / 60
    var seconds = remaining % 60
    time_label.text = "%d:%02d" % [minutes, seconds]

    # Check if timer completed (hide if so)
    if not _timer_state.is_active or _timer_state.is_complete():
        _update_visibility()
```

Create the scripts/ui/ directory if it doesn't exist.

Style the time label using UIStyleHelper patterns from the codebase (pixel-art friendly, warm colors).
  </action>
  <verify>
Verify scene and script parse:
```bash
godot --headless --path . --quit 2>&1 | grep -i error
```
  </verify>
  <done>CircularTimerUI.gd and CircularTimerUI.tscn exist. Component shows circular progress with MM:SS countdown. Hides when timer inactive.</done>
</task>

<task type="auto">
  <name>Task 2: Create StateDebugLabel component</name>
  <files>scripts/ui/StateDebugLabel.gd</files>
  <action>
Create a simple debug label that shows the current state name.

**StateDebugLabel.gd**:
```gdscript
class_name StateDebugLabel
extends Label

var _state_machine: RoomStateMachine = null
var _is_showing := false

func _ready() -> void:
    visible = false
    # Style for debug visibility
    add_theme_color_override("font_color", Color(1.0, 1.0, 0.0, 1.0))  # Yellow
    add_theme_font_size_override("font_size", 12)
    horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER

func set_state_machine(sm: RoomStateMachine) -> void:
    # Disconnect old signal if any
    if _state_machine and _state_machine.state_changed.is_connected(_on_state_changed):
        _state_machine.state_changed.disconnect(_on_state_changed)

    _state_machine = sm

    if _state_machine:
        _state_machine.state_changed.connect(_on_state_changed)
        _update_text()

    _update_visibility()

func show_at_position(world_pos: Vector2) -> void:
    _is_showing = true
    global_position = world_pos - Vector2(size.x / 2.0, 0)  # Center above position
    _update_visibility()

func hide_label() -> void:
    _is_showing = false
    visible = false

func _update_visibility() -> void:
    visible = _is_showing and _state_machine != null and _state_machine.current_state != ""

func _update_text() -> void:
    if _state_machine:
        text = _state_machine.current_state.to_upper()
    else:
        text = ""

func _on_state_changed(_old_state: String, new_state: String) -> void:
    text = new_state.to_upper()
```

This is a simple component - just a Label with state machine binding. It updates automatically when state changes via signal.
  </action>
  <verify>
Verify script parses:
```bash
godot --headless --path . --quit 2>&1 | grep -i error
```
  </verify>
  <done>StateDebugLabel.gd exists. Shows current state name in uppercase. Updates via state_changed signal. Hides when no state machine or state is empty.</done>
</task>

<task type="auto">
  <name>Task 3: Create UI directory structure</name>
  <files>scripts/ui/</files>
  <action>
Ensure the scripts/ui/ directory exists for the new UI components.

```bash
mkdir -p scripts/ui
```

If the directory already exists (from prior work), this is a no-op.

Also verify the scene file is saved correctly by opening in editor briefly or checking file exists.
  </action>
  <verify>
```bash
ls scripts/ui/
```
Should show CircularTimerUI.gd, CircularTimerUI.tscn, StateDebugLabel.gd
  </verify>
  <done>scripts/ui/ directory exists with CircularTimerUI and StateDebugLabel components.</done>
</task>

</tasks>

<verification>
All phase checks for Plan 03:

1. scripts/ui/ directory exists
2. CircularTimerUI.gd exists with set_timer(), show_at_position(), hide_timer() methods
3. CircularTimerUI.tscn is valid scene
4. StateDebugLabel.gd exists with set_state_machine(), show_at_position(), hide_label() methods
5. Both components hide when not showing or when timer/state is inactive
6. Time format is MM:SS (grep for "%d:%02d")
7. No syntax errors

Manual visual test (deferred to integration - these components need to be wired to room selection which happens in a later phase):
- Select room with active timer -> UI appears
- Timer counts down -> progress decreases, time updates
- Timer completes -> UI hides
- State changes -> debug label updates
</verification>

<success_criteria>
- CircularTimerUI component shows circular progress bar with countdown
- CircularTimerUI displays time in MM:SS format
- CircularTimerUI hides when timer not active
- StateDebugLabel shows current state name in uppercase
- StateDebugLabel updates when state changes via signal
- StateDebugLabel hides when no state machine
- Both components have show_at_position() and hide methods for external control
- All files parse without errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-timer-state-foundation/11-03-SUMMARY.md`
</output>
