---
phase: 11-timer-state-foundation
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - scripts/storage/RoomInstance.gd
  - scripts/RoomManager.gd
autonomous: true

must_haves:
  truths:
    - "Room state machine data persists through JSON save/load"
    - "State is recalculated on app resume to account for offline time"
    - "Backward clock manipulation is detected and logged (not punished)"
    - "Corrupted state data resets room to idle and logs recovery"
  artifacts:
    - path: "scripts/storage/RoomInstance.gd"
      provides: "Room data with optional state machine"
      contains: "var state_machine: RoomStateMachine"
    - path: "scripts/RoomManager.gd"
      provides: "Room manager with resume logic"
      contains: "_recalculate_all_room_states"
  key_links:
    - from: "scripts/storage/RoomInstance.gd"
      to: "scripts/state_machine/RoomStateMachine.gd"
      via: "state_machine property"
      pattern: "var state_machine: RoomStateMachine"
    - from: "scripts/RoomManager.gd"
      to: "NOTIFICATION_APPLICATION_RESUMED"
      via: "_notification handler"
      pattern: "NOTIFICATION_APPLICATION_RESUMED"
    - from: "scripts/storage/RoomInstance.gd"
      to: "to_dict/from_dict"
      via: "state_machine serialization"
      pattern: "state_machine.*to_dict"
---

<objective>
Integrate TimerState and RoomStateMachine into the existing persistence system.

Purpose: Enable room state machines to persist through app quit/restart and correctly recalculate state on resume. This extends the existing RoomInstance/RoomManager/RoomSerializer infrastructure without replacing it.

Output: RoomInstance gains an optional state_machine field that serializes through to_dict/from_dict. RoomManager gains resume logic that recalculates all room states on NOTIFICATION_APPLICATION_RESUMED.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-timer-state-foundation/11-CONTEXT.md
@.planning/phases/11-timer-state-foundation/11-RESEARCH.md
@.planning/phases/11-timer-state-foundation/11-01-SUMMARY.md
@scripts/storage/RoomInstance.gd
@scripts/RoomManager.gd
@scripts/storage/RoomSerializer.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend RoomInstance with state_machine field</name>
  <files>scripts/storage/RoomInstance.gd</files>
  <action>
Extend the existing RoomInstance class to support an optional state machine.

Add to class properties (after `furniture` array):
```gdscript
# Optional state machine for rooms with timed states (null if room type doesn't use it)
var state_machine: RoomStateMachine = null
```

Add signal (after existing signals):
```gdscript
signal state_changed(old_state: String, new_state: String)
```

Modify `to_dict()` to include state machine if present:
```gdscript
# After furniture serialization
if state_machine:
    dict["state_machine"] = state_machine.to_dict()
```

Modify `from_dict()` to restore state machine if present. Key detail: state definitions depend on room type, so we need a hook pattern. For Phase 11 (foundation), we'll store the raw data and let room-type-specific code configure the state machine later.

Add near the end of from_dict(), before `return room`:
```gdscript
# Store raw state machine data for later configuration by room type
if data.has("state_machine") and data.state_machine is Dictionary:
    room._pending_state_machine_data = data.state_machine
```

Add a new property to hold pending data:
```gdscript
# Pending state machine data (set by from_dict, consumed by room type initializer)
var _pending_state_machine_data: Dictionary = {}
```

Add a method to initialize state machine with type-specific states:
```gdscript
## Initialize state machine with room-type-specific state definitions.
## Call this after loading, with the state definitions for this room type.
## Returns number of state transitions that occurred during recalculation.
func initialize_state_machine(state_definitions: Dictionary) -> int:
    if state_definitions.is_empty():
        return 0

    if _pending_state_machine_data.is_empty():
        # No saved state - create fresh state machine starting in first defined state
        state_machine = RoomStateMachine.new()
        for state_name in state_definitions:
            var def = state_definitions[state_name]
            state_machine.define_state(def.name, def.duration, def.next_state)
        return 0

    # Restore from saved data
    state_machine = RoomStateMachine.from_dict(_pending_state_machine_data, state_definitions)
    _pending_state_machine_data = {}

    if state_machine == null:
        # Recovery: corrupted data, log and reset
        push_warning("RoomInstance %s: Corrupted state machine data, resetting" % id)
        state_machine = RoomStateMachine.new()
        for state_name in state_definitions:
            var def = state_definitions[state_name]
            state_machine.define_state(def.name, def.duration, def.next_state)
        return 0

    # Connect state changed signal for forwarding
    state_machine.state_changed.connect(_on_state_machine_changed)

    # Recalculate and count transitions
    var transitions = state_machine.recalculate_from_elapsed()
    return transitions

func _on_state_machine_changed(old_state: String, new_state: String) -> void:
    state_changed.emit(old_state, new_state)
    placement_changed.emit()  # Trigger auto-save
```

Update `RoomStateMachine.recalculate_from_elapsed()` to return count (this requires coordinating with Plan 01's output - if the method doesn't return count, modify it to do so).

Bump SCHEMA_VERSION to 2.

Error handling in from_dict: If state_machine data is present but malformed, log warning and skip (room will have null state_machine).
  </action>
  <verify>
Verify RoomInstance still parses and existing tests pass:
```bash
godot --headless --path . -s addons/gut/gut_cmdln.gd -gdir=res://test/unit -ginclude_subdirs=true 2>&1 | tail -20
```
  </verify>
  <done>RoomInstance.gd has state_machine field, _pending_state_machine_data, initialize_state_machine() method, and state_changed signal. SCHEMA_VERSION is 2.</done>
</task>

<task type="auto">
  <name>Task 2: Extend RoomManager with resume logic and timestamp tracking</name>
  <files>scripts/RoomManager.gd</files>
  <action>
Extend RoomManager to handle app resume by recalculating room states.

Add properties for timestamp tracking (after existing properties):
```gdscript
# Timestamp tracking for clock manipulation detection
var _last_known_timestamp: int = 0
const TIMESTAMP_SAVE_KEY := "last_timestamp"
```

Add to _notification() handler (existing NOTIFICATION_APPLICATION_PAUSED case, and new RESUMED case):
```gdscript
func _notification(what: int) -> void:
    match what:
        NOTIFICATION_APPLICATION_PAUSED:
            # App going to background (mobile) - save immediately
            _last_known_timestamp = int(Time.get_unix_time_from_system())
            if _save_pending:
                _save_debounce_timer.stop()
                _perform_save()
        NOTIFICATION_APPLICATION_RESUMED:
            # App returned from background - check for clock manipulation and recalculate states
            _handle_app_resume()
        NOTIFICATION_WM_CLOSE_REQUEST:
            # Window close requested (desktop) - save immediately
            if _save_pending:
                _save_debounce_timer.stop()
                _perform_save()
```

Add resume handler:
```gdscript
func _handle_app_resume() -> void:
    var current_time = int(Time.get_unix_time_from_system())

    # Check for backward clock manipulation
    if _last_known_timestamp > 0 and current_time < _last_known_timestamp:
        var jump_seconds = _last_known_timestamp - current_time
        print("RoomManager: Backward clock jump detected (%d seconds). Ignoring." % jump_seconds)
        # Don't update _last_known_timestamp - keep the forward progress
    else:
        _last_known_timestamp = current_time

    # Recalculate all room states
    var total_transitions = _recalculate_all_room_states()

    if total_transitions > 0:
        room_states_recalculated.emit(total_transitions)
        print("RoomManager: %d state transitions occurred while app was backgrounded" % total_transitions)
```

Add signal for resume notification:
```gdscript
signal room_states_recalculated(transition_count: int)
```

Add recalculation method:
```gdscript
func _recalculate_all_room_states() -> int:
    var total_transitions := 0
    for room in _rooms:
        if room.state_machine:
            var transitions = room.state_machine.recalculate_from_elapsed()
            total_transitions += transitions
    return total_transitions
```

Also update _load_saved_rooms() to track timestamp and recalculate states after loading:
```gdscript
func _load_saved_rooms() -> void:
    var saved_rooms := RoomSerializer.load_rooms()

    # ... existing room loading code ...

    # After all rooms loaded, recalculate states (simulates resume from closed app)
    var total_transitions := 0
    for room in _rooms:
        if room.state_machine:
            total_transitions += room.state_machine.recalculate_from_elapsed()

    if total_transitions > 0:
        room_states_recalculated.emit(total_transitions)
        print("RoomManager: %d state transitions occurred while app was closed" % total_transitions)

    # Initialize timestamp
    _last_known_timestamp = int(Time.get_unix_time_from_system())
```

Note: Rooms won't have state machines until room-type-specific code calls initialize_state_machine(). This is foundation infrastructure - theater-specific state machine setup happens in Phase 13.
  </action>
  <verify>
Verify RoomManager still works:
```bash
godot --headless --path . -s addons/gut/gut_cmdln.gd -gdir=res://test/unit -ginclude_subdirs=true 2>&1 | tail -20
```
  </verify>
  <done>RoomManager.gd handles NOTIFICATION_APPLICATION_RESUMED, tracks timestamps for clock manipulation detection, and recalculates room states on resume. New signal room_states_recalculated is emitted.</done>
</task>

<task type="auto">
  <name>Task 3: Update RoomStateMachine to return transition count</name>
  <files>scripts/state_machine/RoomStateMachine.gd</files>
  <action>
Update RoomStateMachine.recalculate_from_elapsed() to return the number of transitions that occurred.

Modify the method signature and implementation:
```gdscript
## Called on app resume to fast-forward through offline transitions.
## Returns the number of state transitions that occurred.
func recalculate_from_elapsed() -> int:
    var transition_count := 0

    while timer and timer.is_complete():
        var state_def = states.get(current_state)
        if state_def and state_def.next_state != "":
            # Account for overflow into next state
            var overflow = timer.get_elapsed() - timer.duration
            transition_to(state_def.next_state)
            transition_count += 1
            if timer and timer.is_active:
                timer.start_time -= overflow  # Back-date to account for overflow
        else:
            break  # No next state, stop

    return transition_count
```

Also add an update() method that returns whether a transition occurred:
```gdscript
## Call on _process or periodically to check for auto-transitions.
## Returns true if a transition occurred.
func update() -> bool:
    if timer and timer.is_complete():
        var state_def = states.get(current_state)
        if state_def and state_def.next_state != "":
            transition_to(state_def.next_state)
            return true
    return false
```
  </action>
  <verify>
Verify file parses:
```bash
godot --headless --path . --quit 2>&1 | grep -i error
```
  </verify>
  <done>RoomStateMachine.recalculate_from_elapsed() returns int count of transitions. update() returns bool for single transition check.</done>
</task>

</tasks>

<verification>
All phase checks for Plan 02:

1. RoomInstance.state_machine field exists (grep for "var state_machine: RoomStateMachine")
2. RoomInstance.to_dict() includes state_machine (grep for "state_machine.*to_dict")
3. RoomInstance.from_dict() handles state_machine data
4. RoomManager handles NOTIFICATION_APPLICATION_RESUMED
5. RoomManager._recalculate_all_room_states() exists and loops through rooms
6. Timestamp tracking for clock manipulation exists
7. Existing tests still pass

Integration test (manual):
```gdscript
# In Godot console or test script
var room = RoomInstance.new("test-1", "theater")
var states = {}
states["idle"] = StateDefinition.new("idle", 0, "")
states["playing"] = StateDefinition.new("playing", 60, "idle")
room.initialize_state_machine(states)
room.state_machine.transition_to("idle")
print(room.to_dict())  # Should include state_machine key
```
</verification>

<success_criteria>
- RoomInstance has state_machine field (nullable RoomStateMachine)
- RoomInstance.to_dict() serializes state_machine if present
- RoomInstance.from_dict() restores pending state machine data
- RoomInstance.initialize_state_machine() configures state machine with definitions
- RoomInstance.state_changed signal forwards state machine changes
- RoomManager handles NOTIFICATION_APPLICATION_RESUMED
- RoomManager._recalculate_all_room_states() iterates rooms and returns count
- RoomManager.room_states_recalculated signal emitted on resume with count
- RoomManager tracks last_known_timestamp and logs backward clock jumps
- Existing unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-timer-state-foundation/11-02-SUMMARY.md`
</output>
