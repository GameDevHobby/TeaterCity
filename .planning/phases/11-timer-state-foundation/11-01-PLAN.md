---
phase: 11-timer-state-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/storage/TimerState.gd
  - scripts/state_machine/RoomStateMachine.gd
  - scripts/state_machine/StateDefinition.gd
autonomous: true

must_haves:
  truths:
    - "TimerState calculates elapsed time correctly using Unix timestamps"
    - "TimerState reports remaining time and completion status"
    - "RoomStateMachine can define states with timed auto-transitions"
    - "RoomStateMachine can fast-forward through multiple state transitions on recalculate"
  artifacts:
    - path: "scripts/storage/TimerState.gd"
      provides: "Timestamp-based offline timer"
      exports: ["TimerState"]
    - path: "scripts/state_machine/RoomStateMachine.gd"
      provides: "Abstract state machine for rooms"
      exports: ["RoomStateMachine"]
    - path: "scripts/state_machine/StateDefinition.gd"
      provides: "Data class for state configuration"
      exports: ["StateDefinition"]
  key_links:
    - from: "scripts/state_machine/RoomStateMachine.gd"
      to: "scripts/storage/TimerState.gd"
      via: "timer property"
      pattern: "var timer: TimerState"
    - from: "scripts/state_machine/RoomStateMachine.gd"
      to: "scripts/state_machine/StateDefinition.gd"
      via: "states dictionary"
      pattern: "var states: Dictionary.*StateDefinition"
---

<objective>
Create the core data classes for offline-capable timers and data-driven room state machines.

Purpose: Establish the foundational infrastructure that theater rooms (and future room types) will use for timed activities and state tracking. These classes must work offline by using Unix timestamps rather than Timer nodes.

Output: Three RefCounted classes (TimerState, StateDefinition, RoomStateMachine) that can be serialized to JSON and correctly recalculate state after app resume.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-timer-state-foundation/11-CONTEXT.md
@.planning/phases/11-timer-state-foundation/11-RESEARCH.md
@scripts/storage/RoomInstance.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TimerState class</name>
  <files>scripts/storage/TimerState.gd</files>
  <action>
Create a new RefCounted class `TimerState` that tracks timer state using Unix timestamps.

CRITICAL: Use `int(Time.get_unix_time_from_system())` - NEVER store as float (causes JSON scientific notation corruption).

Properties:
- `start_time: int` - Unix timestamp when timer started (0 if not started)
- `duration: int` - Duration in seconds
- `is_active: bool` - Whether timer is running

Methods:
- `start(duration_seconds: int)` - Start timer with given duration, sets start_time to current Unix time
- `stop()` - Stop timer (set is_active = false)
- `get_elapsed() -> int` - Returns elapsed seconds (clamped to >= 0 to handle backward clock manipulation)
- `get_remaining() -> int` - Returns remaining seconds (clamped to >= 0)
- `is_complete() -> bool` - Returns true if timer is active AND elapsed >= duration
- `to_dict() -> Dictionary` - Serialize to JSON-safe dictionary
- `static func from_dict(data: Dictionary) -> TimerState` - Deserialize from dictionary

Follow the pattern from RoomInstance inner classes (DoorPlacement, FurniturePlacement).

Handle edge cases:
- Not active timer returns 0 for elapsed
- Backward clock manipulation: clamp elapsed to maxi(0, elapsed)
- Null/missing data in from_dict: use safe defaults
  </action>
  <verify>
Create the file and verify it parses without syntax errors:
```bash
godot --headless --script scripts/storage/TimerState.gd --quit 2>&1 | head -20
```
Or check via editor validation.
  </verify>
  <done>TimerState.gd exists with all specified methods. The class uses int timestamps and handles edge cases.</done>
</task>

<task type="auto">
  <name>Task 2: Create StateDefinition and RoomStateMachine classes</name>
  <files>scripts/state_machine/StateDefinition.gd, scripts/state_machine/RoomStateMachine.gd</files>
  <action>
Create two new RefCounted classes for data-driven state machines.

**StateDefinition.gd** (simple data class):
```gdscript
class_name StateDefinition
extends RefCounted

var name: String
var duration: int = 0  # 0 = no auto-transition
var next_state: String = ""  # Empty = no auto-transition

func _init(p_name: String = "", p_duration: int = 0, p_next: String = "") -> void:
    name = p_name
    duration = p_duration
    next_state = p_next
```

**RoomStateMachine.gd**:

Properties:
- `current_state: String` - Current state name (empty string if not initialized)
- `timer: TimerState` - Timer for current state (null if state has no duration)
- `states: Dictionary` - state_name -> StateDefinition mapping

Signals:
- `state_changed(old_state: String, new_state: String)` - Emitted on state transition

Methods:
- `define_state(name: String, duration: int = 0, next_state: String = "")` - Register a state definition
- `transition_to(new_state: String)` - Transition to a new state; starts timer if state has duration
- `update()` - Check if current timer complete and auto-transition if needed (call from _process or periodically)
- `recalculate_from_elapsed()` - Fast-forward through all completed states (call on app resume). This loops through transitions as long as timer is complete and next_state exists.
- `to_dict() -> Dictionary` - Serialize (current_state + timer)
- `static func from_dict(data: Dictionary, state_definitions: Dictionary) -> RoomStateMachine` - Deserialize with state definitions

Key implementation detail for `recalculate_from_elapsed()`:
When a timer completes and transitions to next state, account for overflow time:
```gdscript
var overflow = timer.get_elapsed() - timer.duration
transition_to(state_def.next_state)
if timer and timer.is_active:
    timer.start_time -= overflow  # Back-date to account for overflow
```

Error handling:
- `transition_to()` with unknown state: push_error and return without changing state
- Invalid data in from_dict: reset to empty state, log warning

Create the `scripts/state_machine/` directory if it doesn't exist.
  </action>
  <verify>
Verify both files parse without errors:
```bash
godot --headless --path . --quit 2>&1 | grep -i error
```
  </verify>
  <done>StateDefinition.gd and RoomStateMachine.gd exist in scripts/state_machine/. RoomStateMachine can define states, transition, and recalculate elapsed time through multiple transitions.</done>
</task>

</tasks>

<verification>
All phase checks for Plan 01:

1. TimerState uses int timestamps (grep for "int(Time.get_unix_time_from_system())")
2. TimerState has to_dict/from_dict matching RoomInstance pattern
3. RoomStateMachine uses TimerState (not Timer node)
4. RoomStateMachine.recalculate_from_elapsed() handles overflow correctly
5. All classes are RefCounted (not Node)
6. No syntax errors when loading in Godot

Manual verification:
```gdscript
# Quick test in Godot console or script
var timer = TimerState.new()
timer.start(60)
print(timer.get_elapsed())  # Should be ~0
print(timer.get_remaining())  # Should be ~60
print(timer.is_complete())  # Should be false
```
</verification>

<success_criteria>
- TimerState.gd exists and uses Unix timestamps as int
- StateDefinition.gd exists as simple data class
- RoomStateMachine.gd exists with state_changed signal
- All three classes extend RefCounted
- All three classes have to_dict() and from_dict() serialization
- RoomStateMachine.recalculate_from_elapsed() loops through completed states with overflow handling
</success_criteria>

<output>
After completion, create `.planning/phases/11-timer-state-foundation/11-01-SUMMARY.md`
</output>
