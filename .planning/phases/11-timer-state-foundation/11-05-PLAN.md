---
phase: 11-timer-state-foundation
plan: 05
type: execute
wave: 3
depends_on: ["11-02"]
files_modified:
  - test/unit/test_timer_state.gd
  - test/unit/test_room_state_machine.gd
  - test/integration/test_timer_persistence.gd
autonomous: true

must_haves:
  truths:
    - "TimerState reports correct elapsed time after simulated offline period"
    - "TimerState handles backward clock manipulation gracefully"
    - "RoomStateMachine transitions correctly through multiple states on recalculate"
    - "State machine data survives serialization round-trip"
  artifacts:
    - path: "test/unit/test_timer_state.gd"
      provides: "Unit tests for TimerState"
      contains: "class_name TestTimerState"
    - path: "test/unit/test_room_state_machine.gd"
      provides: "Unit tests for RoomStateMachine"
      contains: "class_name TestRoomStateMachine"
    - path: "test/integration/test_timer_persistence.gd"
      provides: "Integration tests for timer persistence"
      contains: "class_name TestTimerPersistence"
  key_links:
    - from: "test/unit/test_timer_state.gd"
      to: "Scripts/storage/TimerState.gd"
      via: "test subject"
      pattern: "TimerState.new"
    - from: "test/integration/test_timer_persistence.gd"
      to: "Scripts/storage/RoomInstance.gd"
      via: "persistence test"
      pattern: "RoomInstance.*to_dict.*from_dict"
---

<objective>
Create comprehensive unit and integration tests for the timer and state machine infrastructure.

Purpose: Verify TIMER-01, TIMER-02, STATE-01, STATE-02 requirements are met. Tests should cover offline simulation, clock manipulation, serialization round-trip, and multi-state recalculation. Following GUT framework patterns established in v1.0.

Output: Test files that verify all success criteria from ROADMAP.md Phase 11.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-timer-state-foundation/11-CONTEXT.md
@.planning/phases/11-timer-state-foundation/11-01-SUMMARY.md
@.planning/phases/11-timer-state-foundation/11-02-SUMMARY.md
@test/unit/test_room_instance.gd
@test/unit/test_room_serializer.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TimerState unit tests</name>
  <files>test/unit/test_timer_state.gd</files>
  <action>
Create comprehensive unit tests for TimerState class.

Follow existing GUT test patterns in test/unit/.

```gdscript
class_name TestTimerState
extends GutTest

var timer: TimerState

func before_each() -> void:
    timer = TimerState.new()

func after_each() -> void:
    timer = null

# --- Basic Functionality ---

func test_initial_state() -> void:
    assert_eq(timer.start_time, 0, "start_time should be 0 initially")
    assert_eq(timer.duration, 0, "duration should be 0 initially")
    assert_false(timer.is_active, "should not be active initially")

func test_start_sets_active() -> void:
    timer.start(60)
    assert_true(timer.is_active, "should be active after start")
    assert_eq(timer.duration, 60, "duration should be set")
    assert_true(timer.start_time > 0, "start_time should be set to current time")

func test_stop_clears_active() -> void:
    timer.start(60)
    timer.stop()
    assert_false(timer.is_active, "should not be active after stop")

func test_elapsed_when_not_active() -> void:
    assert_eq(timer.get_elapsed(), 0, "elapsed should be 0 when not active")

func test_remaining_calculation() -> void:
    timer.start(60)
    # Immediately after start, remaining should be close to duration
    var remaining = timer.get_remaining()
    assert_true(remaining >= 59 and remaining <= 60, "remaining should be near duration immediately after start")

func test_is_complete_false_when_time_remaining() -> void:
    timer.start(3600)  # 1 hour
    assert_false(timer.is_complete(), "should not be complete with time remaining")

# --- Offline Simulation ---

func test_elapsed_after_simulated_offline() -> void:
    # Simulate timer started 30 seconds ago
    timer.is_active = true
    timer.duration = 60
    timer.start_time = int(Time.get_unix_time_from_system()) - 30

    var elapsed = timer.get_elapsed()
    assert_true(elapsed >= 29 and elapsed <= 31, "elapsed should be ~30 seconds: got %d" % elapsed)

func test_is_complete_after_duration_passed() -> void:
    # Simulate timer started 120 seconds ago with 60 second duration
    timer.is_active = true
    timer.duration = 60
    timer.start_time = int(Time.get_unix_time_from_system()) - 120

    assert_true(timer.is_complete(), "should be complete when elapsed > duration")

func test_remaining_clamps_to_zero() -> void:
    # Simulate timer expired long ago
    timer.is_active = true
    timer.duration = 60
    timer.start_time = int(Time.get_unix_time_from_system()) - 3600  # 1 hour ago

    assert_eq(timer.get_remaining(), 0, "remaining should clamp to 0")

# --- Clock Manipulation ---

func test_backward_clock_clamps_to_zero() -> void:
    # Simulate clock set backward (start_time in future)
    timer.is_active = true
    timer.duration = 60
    timer.start_time = int(Time.get_unix_time_from_system()) + 100  # 100 seconds in future

    var elapsed = timer.get_elapsed()
    assert_eq(elapsed, 0, "elapsed should clamp to 0 for backward clock")

# --- Serialization ---

func test_to_dict_format() -> void:
    timer.start(120)
    var dict = timer.to_dict()

    assert_true(dict.has("start_time"), "should have start_time")
    assert_true(dict.has("duration"), "should have duration")
    assert_true(dict.has("is_active"), "should have is_active")
    assert_eq(dict.duration, 120, "duration should match")
    assert_true(dict.is_active, "is_active should match")

func test_from_dict_restores_state() -> void:
    timer.start(180)
    var dict = timer.to_dict()

    var restored = TimerState.from_dict(dict)
    assert_eq(restored.start_time, timer.start_time, "start_time should be restored")
    assert_eq(restored.duration, timer.duration, "duration should be restored")
    assert_eq(restored.is_active, timer.is_active, "is_active should be restored")

func test_from_dict_handles_missing_fields() -> void:
    var restored = TimerState.from_dict({})
    assert_eq(restored.start_time, 0, "should default to 0")
    assert_eq(restored.duration, 0, "should default to 0")
    assert_false(restored.is_active, "should default to false")

func test_start_time_is_int() -> void:
    timer.start(60)
    var dict = timer.to_dict()
    # Verify start_time is int (not float that could corrupt to scientific notation)
    assert_true(dict.start_time is int, "start_time should be int, got %s" % typeof(dict.start_time))
```
  </action>
  <verify>
Run tests:
```bash
godot --headless --path . -s addons/gut/gut_cmdln.gd -gtest=res://test/unit/test_timer_state.gd 2>&1 | tail -30
```
  </verify>
  <done>test/unit/test_timer_state.gd exists with tests for basic functionality, offline simulation, clock manipulation, and serialization.</done>
</task>

<task type="auto">
  <name>Task 2: Create RoomStateMachine unit tests</name>
  <files>test/unit/test_room_state_machine.gd</files>
  <action>
Create comprehensive unit tests for RoomStateMachine class.

```gdscript
class_name TestRoomStateMachine
extends GutTest

var sm: RoomStateMachine

func before_each() -> void:
    sm = RoomStateMachine.new()
    # Define test states: idle -> active (10s) -> cooldown (5s) -> idle
    sm.define_state("idle", 0, "")  # No auto-transition
    sm.define_state("active", 10, "cooldown")  # 10s then -> cooldown
    sm.define_state("cooldown", 5, "idle")  # 5s then -> idle

func after_each() -> void:
    sm = null

# --- State Definition ---

func test_define_state_adds_to_dictionary() -> void:
    assert_true("idle" in sm.states, "idle should be defined")
    assert_true("active" in sm.states, "active should be defined")
    assert_true("cooldown" in sm.states, "cooldown should be defined")

func test_state_definition_properties() -> void:
    var active_def = sm.states["active"]
    assert_eq(active_def.name, "active", "name should match")
    assert_eq(active_def.duration, 10, "duration should match")
    assert_eq(active_def.next_state, "cooldown", "next_state should match")

# --- State Transitions ---

func test_transition_to_valid_state() -> void:
    sm.transition_to("idle")
    assert_eq(sm.current_state, "idle", "should be in idle state")

func test_transition_to_timed_state_starts_timer() -> void:
    sm.transition_to("active")
    assert_not_null(sm.timer, "timer should be created")
    assert_true(sm.timer.is_active, "timer should be active")
    assert_eq(sm.timer.duration, 10, "timer duration should match state duration")

func test_transition_to_untimed_state_stops_timer() -> void:
    sm.transition_to("active")  # Start with timed state
    sm.transition_to("idle")  # Switch to untimed
    assert_false(sm.timer.is_active, "timer should be inactive for untimed state")

func test_transition_to_unknown_state_does_nothing() -> void:
    sm.transition_to("idle")
    sm.transition_to("nonexistent")
    assert_eq(sm.current_state, "idle", "should remain in idle for unknown state")

# --- Signal Emission ---

func test_state_changed_signal_emitted() -> void:
    var signal_received = false
    var received_old = ""
    var received_new = ""

    sm.state_changed.connect(func(old, new):
        signal_received = true
        received_old = old
        received_new = new
    )

    sm.transition_to("active")

    assert_true(signal_received, "state_changed should be emitted")
    assert_eq(received_old, "", "old state should be empty initially")
    assert_eq(received_new, "active", "new state should be active")

# --- Update (single transition check) ---

func test_update_no_transition_when_timer_not_complete() -> void:
    sm.transition_to("active")
    var transitioned = sm.update()
    assert_false(transitioned, "should not transition when timer not complete")
    assert_eq(sm.current_state, "active", "should remain in active")

func test_update_transitions_when_timer_complete() -> void:
    sm.transition_to("active")
    # Simulate timer completion
    sm.timer.start_time = int(Time.get_unix_time_from_system()) - 20  # 20s ago, > 10s duration

    var transitioned = sm.update()
    assert_true(transitioned, "should transition when timer complete")
    assert_eq(sm.current_state, "cooldown", "should be in cooldown state")

# --- Recalculate From Elapsed (multi-transition) ---

func test_recalculate_no_transitions_when_fresh() -> void:
    sm.transition_to("idle")
    var count = sm.recalculate_from_elapsed()
    assert_eq(count, 0, "no transitions for fresh idle state")

func test_recalculate_single_transition() -> void:
    sm.transition_to("active")
    # Simulate 15 seconds passed (> 10s duration, should transition to cooldown)
    sm.timer.start_time = int(Time.get_unix_time_from_system()) - 15

    var count = sm.recalculate_from_elapsed()
    assert_eq(count, 1, "should have 1 transition")
    assert_eq(sm.current_state, "cooldown", "should be in cooldown")

func test_recalculate_multiple_transitions() -> void:
    sm.transition_to("active")
    # Simulate 20 seconds passed (> 10s active + 5s cooldown = 15s total)
    # Should transition: active -> cooldown -> idle
    sm.timer.start_time = int(Time.get_unix_time_from_system()) - 20

    var count = sm.recalculate_from_elapsed()
    assert_eq(count, 2, "should have 2 transitions")
    assert_eq(sm.current_state, "idle", "should end in idle")

func test_recalculate_stops_at_untimed_state() -> void:
    sm.transition_to("active")
    # Simulate very long time passed
    sm.timer.start_time = int(Time.get_unix_time_from_system()) - 3600  # 1 hour

    var count = sm.recalculate_from_elapsed()
    assert_eq(sm.current_state, "idle", "should end in idle")
    # Stops at idle because idle has no next_state

# --- Serialization ---

func test_to_dict_format() -> void:
    sm.transition_to("active")
    var dict = sm.to_dict()

    assert_true(dict.has("current_state"), "should have current_state")
    assert_eq(dict.current_state, "active", "current_state should match")
    assert_true(dict.has("timer"), "should have timer")

func test_from_dict_restores_state() -> void:
    sm.transition_to("active")
    var dict = sm.to_dict()

    var restored = RoomStateMachine.from_dict(dict, sm.states)
    assert_eq(restored.current_state, "active", "current_state should be restored")
    assert_not_null(restored.timer, "timer should be restored")
    assert_eq(restored.timer.duration, 10, "timer duration should be restored")

func test_from_dict_handles_null_timer() -> void:
    sm.transition_to("idle")
    var dict = sm.to_dict()

    var restored = RoomStateMachine.from_dict(dict, sm.states)
    assert_eq(restored.current_state, "idle", "should restore idle state")
```
  </action>
  <verify>
Run tests:
```bash
godot --headless --path . -s addons/gut/gut_cmdln.gd -gtest=res://test/unit/test_room_state_machine.gd 2>&1 | tail -30
```
  </verify>
  <done>test/unit/test_room_state_machine.gd exists with tests for state definition, transitions, signals, update, recalculate, and serialization.</done>
</task>

<task type="auto">
  <name>Task 3: Create timer persistence integration tests</name>
  <files>test/integration/test_timer_persistence.gd</files>
  <action>
Create integration tests that verify timer and state machine data persists through RoomInstance serialization.

```gdscript
class_name TestTimerPersistence
extends GutTest

# --- Integration tests for timer/state machine persistence ---

func test_room_instance_with_state_machine_serializes() -> void:
    # Create room with state machine
    var room = RoomInstance.new("test-1", "theater")
    room.bounding_box = Rect2i(0, 0, 5, 5)

    # Set up state machine
    var states = {}
    states["idle"] = StateDefinition.new("idle", 0, "")
    states["playing"] = StateDefinition.new("playing", 60, "cleaning")
    states["cleaning"] = StateDefinition.new("cleaning", 30, "idle")

    room.initialize_state_machine(states)
    room.state_machine.transition_to("playing")

    # Serialize
    var dict = room.to_dict()

    # Verify state machine is in dict
    assert_true(dict.has("state_machine"), "should have state_machine in dict")
    assert_eq(dict.state_machine.current_state, "playing", "state should be playing")

func test_room_instance_state_machine_round_trip() -> void:
    # Create and configure original
    var original = RoomInstance.new("test-2", "theater")
    original.bounding_box = Rect2i(0, 0, 5, 5)

    var states = {}
    states["idle"] = StateDefinition.new("idle", 0, "")
    states["scheduled"] = StateDefinition.new("scheduled", 10, "playing")
    states["playing"] = StateDefinition.new("playing", 60, "idle")

    original.initialize_state_machine(states)
    original.state_machine.transition_to("scheduled")

    # Serialize and deserialize
    var dict = original.to_dict()
    var restored = RoomInstance.from_dict(dict)

    # Initialize state machine on restored room
    restored.initialize_state_machine(states)

    # Verify
    assert_eq(restored.state_machine.current_state, "scheduled", "state should be restored")
    assert_true(restored.state_machine.timer.is_active, "timer should be active")

func test_state_recalculates_on_restore() -> void:
    # Create room with state machine
    var room = RoomInstance.new("test-3", "theater")
    room.bounding_box = Rect2i(0, 0, 5, 5)

    var states = {}
    states["idle"] = StateDefinition.new("idle", 0, "")
    states["playing"] = StateDefinition.new("playing", 10, "idle")  # 10 second duration

    room.initialize_state_machine(states)
    room.state_machine.transition_to("playing")

    # Simulate time passing (backdate timer start)
    room.state_machine.timer.start_time = int(Time.get_unix_time_from_system()) - 20  # 20s ago

    # Serialize
    var dict = room.to_dict()

    # Deserialize
    var restored = RoomInstance.from_dict(dict)
    var transitions = restored.initialize_state_machine(states)

    # Should have auto-transitioned to idle
    assert_eq(transitions, 1, "should have 1 transition on recalculate")
    assert_eq(restored.state_machine.current_state, "idle", "should be in idle after recalculate")

func test_corrupted_state_machine_data_recovers() -> void:
    # Create room with intentionally corrupted state machine data
    var dict = {
        "schema_version": 2,
        "id": "test-4",
        "room_type_id": "theater",
        "bounding_box": {"x": 0, "y": 0, "width": 5, "height": 5},
        "walls": [],
        "doors": [],
        "furniture": [],
        "state_machine": {
            "current_state": "nonexistent_state",  # Invalid state
            "timer": {"start_time": "invalid", "duration": "bad", "is_active": "yes"}  # Invalid types
        }
    }

    var states = {}
    states["idle"] = StateDefinition.new("idle", 0, "")

    var restored = RoomInstance.from_dict(dict)
    var transitions = restored.initialize_state_machine(states)

    # Should recover gracefully
    assert_not_null(restored.state_machine, "should have state machine after recovery")
    # The implementation should either reset to first state or handle the error

func test_room_without_state_machine_serializes_normally() -> void:
    # Room without state machine should work as before
    var room = RoomInstance.new("test-5", "lobby")
    room.bounding_box = Rect2i(0, 0, 3, 3)

    var dict = room.to_dict()
    assert_false(dict.has("state_machine"), "should not have state_machine key")

    var restored = RoomInstance.from_dict(dict)
    assert_null(restored.state_machine, "state_machine should remain null")
```

Create test/integration/ directory if it doesn't exist.
  </action>
  <verify>
Run tests:
```bash
godot --headless --path . -s addons/gut/gut_cmdln.gd -gtest=res://test/integration/test_timer_persistence.gd 2>&1 | tail -30
```
  </verify>
  <done>test/integration/test_timer_persistence.gd exists with integration tests for serialization round-trip and state recalculation on restore.</done>
</task>

</tasks>

<verification>
All phase checks for Plan 05:

1. test/unit/test_timer_state.gd exists with 10+ test functions
2. test/unit/test_room_state_machine.gd exists with 10+ test functions
3. test/integration/test_timer_persistence.gd exists with 5+ test functions
4. All tests pass when run via GUT

Run full test suite:
```bash
godot --headless --path . -s addons/gut/gut_cmdln.gd -gdir=res://test -ginclude_subdirs=true 2>&1 | tail -50
```

Tests should cover:
- [x] TimerState elapsed time after simulated offline
- [x] TimerState backward clock handling
- [x] RoomStateMachine multi-state recalculation
- [x] Serialization round-trip
- [x] Error recovery for corrupted data
</verification>

<success_criteria>
- test_timer_state.gd covers: initial state, start/stop, elapsed/remaining, offline simulation, clock manipulation, serialization
- test_room_state_machine.gd covers: state definition, transitions, signals, update, recalculate, serialization
- test_timer_persistence.gd covers: RoomInstance with state machine serialization, round-trip restore, recalculation on load, error recovery
- All tests pass
- Test count increases project total (was 91 in v1.0)
</success_criteria>

<output>
After completion, create `.planning/phases/11-timer-state-foundation/11-05-SUMMARY.md`
</output>
