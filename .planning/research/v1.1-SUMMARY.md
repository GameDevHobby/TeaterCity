# Research Summary: Theater Core Mechanics (v1.1)

**Project:** TheaterCity
**Milestone:** v1.1 Theater Core Mechanics
**Synthesized:** 2026-02-08
**Overall Confidence:** HIGH

---

## Executive Summary

Building theater mechanics for TheaterCity requires three core additions: (1) a timestamp-based timer system for offline progression, (2) a RefCounted state machine for theater states, and (3) a MovieRegistry following existing patterns. All components integrate cleanly with existing architecture - no new dependencies required.

**Critical insight:** Use Unix timestamps (not Timer nodes) for offline progression. Timer nodes stop when app closes. Store `Time.get_unix_time_from_system()` as integer, calculate elapsed on resume.

**Top risks:** Timestamp stored as float (corrupts to scientific notation), system clock manipulation (skip timers), missing app pause handler (Android kills without warning), state not recalculated on load.

**Recommended approach:** Foundation first (TimerState, TheaterState data models), then operations (stateless helpers), then controller (orchestration), then UI (scheduling), then patron integration.

---

## Technology Decisions

### Core Stack (No New Dependencies)

| Technology | Purpose | Rationale |
|------------|---------|-----------|
| **Time.get_unix_time_from_system()** | Offline timer tracking | Returns Unix timestamp, works across app restarts |
| **RefCounted FSM** | Theater state machine | Lightweight, serializable, follows RoomInstance pattern |
| **MovieRegistry singleton** | Movie data lookup | Follows FurnitureRegistry pattern exactly |
| **Existing RoomSerializer** | Timer/state persistence | JSON already handles new fields via to_dict() |

### Why NOT LimboHSM for Theater States

- LimboHSM is scene-based (Node in tree)
- Theater state is data (like furniture placement), not behavior
- RefCounted state matches existing RoomInstance pattern
- Simpler serialization (just add fields to to_dict())

### New Components to Create

| Component | Type | Purpose |
|-----------|------|---------|
| TimerState | RefCounted | Abstract timer with timestamp tracking |
| TheaterState | RefCounted | Theater-specific state machine |
| MovieResource | Resource | Movie data (title, genre, rating, duration) |
| MovieRegistry | Resource singleton | Movie lookup with lazy loading |
| TimerOperation | RefCounted | Stateless timer logic helpers |
| TheaterController | Node | Orchestrates theater updates |
| MovieSchedulingUI | Control | Player selects/assigns movies |

---

## Feature Priorities

### Table Stakes (Must Have for v1.1)

| Feature | Complexity | Notes |
|---------|------------|-------|
| Theater state machine | Medium | Idle → Scheduled → Previews → Playing → Cleaning |
| Movie selection UI | Low | Pick from MovieRegistry, assign to theater |
| Duration-based transitions | Medium | Timestamp calculation, offline-capable |
| Patron seat claiming | Medium | Pathfind to theater, claim seat, watch |
| Theater capacity | Low | max_seats property, track occupied |
| State visual feedback | Low | Color/icon change per state |
| Cleanup transition | Low | Brief state after movie ends |

### Defer to v1.2+

| Feature | Why Defer |
|---------|-----------|
| Patron genre preferences | Adds complexity, patrons watch anything for now |
| Movie popularity affecting spawn | Needs preference system first |
| Multiple simultaneous showings | Robust architecture first |
| Time-of-day scheduling | Requires game-wide time system |

### Anti-Features (Don't Build)

| Feature | Why Avoid |
|---------|-----------|
| Complex movie budgeting | Distracts from core venue simulation |
| Real-time movie playback | Breaks mobile pacing (need 30s-90s loops) |
| Patron complaints system | Micro-management hell |
| Detailed seat layout editor | Over-complicates room building |

---

## Risk Mitigation

### Critical Pitfalls (Must Address)

| Pitfall | Impact | Prevention | Phase |
|---------|--------|------------|-------|
| **Timer nodes for offline** | Progression broken | Use Unix timestamps, not Timer nodes | 1 |
| **Float → scientific notation** | JSON corruption | Convert timestamp to int before saving | 1 |
| **System clock cheating** | Players skip timers | Cap elapsed time, detect time jumps | 2 |
| **Missing app pause handler** | Data loss on Android | Save immediately on NOTIFICATION_APPLICATION_PAUSED | 1 |
| **State not recalculated on load** | Room stuck in wrong state | Recalculate all timers on _ready() | 2 |

### Testing Checklist

- [ ] Start movie → kill app → wait 30 min → relaunch → verify movie completed
- [ ] Start cleaning → change device time forward → verify cleanup completed
- [ ] Start movie → change device time backward → verify no negative elapsed
- [ ] Start movie → switch apps rapidly → verify state persists
- [ ] Fill theater to capacity → verify no more patrons enter

---

## Architecture Integration

### Data Flow

```
Player taps Schedule → MovieSchedulingUI shows movies
    → Player selects movie → TheaterController.schedule_movie(room, movie)
    → TheaterState transitions to SCHEDULED
    → RoomInstance.timer starts (timestamp saved)
    → RoomSerializer persists to JSON

[Time passes, possibly offline]

App resumes → TheaterController._ready()
    → Reads all rooms from RoomSerializer
    → For each theater: recalculate_state(elapsed_time)
    → Transitions states as needed (PLAYING → CLEANING → IDLE)
    → Emits signals for visual updates
```

### Suggested Build Order

| Phase | Name | Dependencies |
|-------|------|--------------|
| 11 | Data Foundation | None - add TimerState, TheaterState, MovieResource |
| 12 | Movie Registry | Phase 11 - MovieRegistry follows existing pattern |
| 13 | Operations | Phase 11 - TimerOperation, TheaterStateOperation |
| 14 | Theater Controller | Phases 11-13 - orchestrates state updates |
| 15 | Scheduling UI | Phase 14 - connects to room-type button |
| 16 | Patron Seating | Phases 14-15 - extend Patron with seating |

---

## Implementation Notes

### Timestamp Pattern

```gdscript
# When state starts
var start_time := int(Time.get_unix_time_from_system())  # int, not float!
room.theater_state.start_time = start_time

# On app resume
var elapsed := int(Time.get_unix_time_from_system()) - room.theater_state.start_time
if elapsed >= state_duration:
    transition_to_next_state()
```

### App Pause Handler

```gdscript
# Already exists in RoomManager, just verify it fires
func _notification(what: int) -> void:
    if what == NOTIFICATION_APPLICATION_PAUSED:
        _save_all_immediately()  # No debounce
```

### State Recalculation on Load

```gdscript
func _ready() -> void:
    var rooms = RoomSerializer.load_rooms()
    for room in rooms:
        _recalculate_theater_state(room)  # CRITICAL
        RoomManager.register_room(room)
```

---

## Research Files

| File | Content |
|------|---------|
| STACK-THEATER-MECHANICS.md | Timer system, LimboHSM analysis, Godot patterns |
| FEATURES-THEATER-MECHANICS.md | Table stakes, differentiators, anti-features |
| ARCHITECTURE.md | Integration points, data flow, build order |
| PITFALLS_OFFLINE_TIMERS.md | 7 critical pitfalls with prevention strategies |

---

**Research complete.** Ready for requirements definition and roadmap creation.
